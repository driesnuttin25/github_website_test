<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Study Trainer</title>

  <!-- Tailwind via CDN (fine for GitHub Pages) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { darkMode: 'class' }
  </script>

  <style>
    /* Swipe feedback + animation */
    .swipe-left  { transform: translateX(-120%) rotate(-6deg); opacity: 0; transition: transform 220ms ease, opacity 220ms ease; }
    .swipe-right { transform: translateX(120%)  rotate( 6deg); opacity: 0; transition: transform 220ms ease, opacity 220ms ease; }

    .progress-fill { transition: width 400ms ease; }

    /* Drag preview helpers */
    .dragging { transition: none !important; }
    .badge {
      position: absolute;
      top: 12px;
      font-weight: 700;
      padding: 6px 10px;
      border-radius: 12px;
      pointer-events: none;
      opacity: 0;
      transform: scale(0.95);
      transition: opacity 120ms ease, transform 120ms ease;
      user-select: none;
    }
    .badge-left  { left: 12px;  background: rgba(244,63,94,0.15);  color: rgb(244,63,94);  border: 1px solid rgba(244,63,94,0.35); }
    .badge-right { right: 12px; background: rgba(34,197,94,0.15); color: rgb(34,197,94); border: 1px solid rgba(34,197,94,0.35); }
  </style>
</head>

<body class="h-full bg-zinc-50 text-zinc-900 dark:bg-zinc-900 dark:text-zinc-50">
  <!--
  ===============================================================
  Flashcard Trainer ‚Äì Single-file app for GitHub Pages
  ---------------------------------------------------------------
  INPUT: chapters.md (ONLY)
  - Put a `chapters.md` file next to this index.html.
  - If chapters.md is missing, it falls back to SAMPLE_CHAPTERS.

  chapters.md format example:

  # Course: Computer Architecture [comp-arch]

  ## Chapter: Internal Memory [internal-memory]

  Q: What is a cache hit?
  A: When the requested data is found in cache.

  ---
  IMG: images/cache.png
  Q: Explain direct-mapped cache.
  A: Each block maps to exactly one cache line.

  NOTES
  - Course/chapter IDs in [brackets] are optional. If omitted, they are auto-slugified from the name.
  - Cards are separated by `---`
  - Q/A can be multi-line (just keep writing on next lines after Q: or A:)
  ===============================================================
  -->

  <header class="sticky top-0 z-50 bg-white/70 backdrop-blur border-b border-zinc-200 dark:bg-zinc-900/70 dark:border-zinc-800">
    <div class="max-w-5xl mx-auto px-4 py-3 flex items-center justify-between">
      <button id="homeBtn" class="flex items-center gap-2 text-zinc-700 dark:text-zinc-200 hover:opacity-80" title="Home (H)">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
          <path d="M11.47 3.84a.75.75 0 0 1 1.06 0l8.69 8.69a.75.75 0 0 1-1.06 1.06l-.9-.9V20a2 2 0 0 1-2 2h-3.25a.75.75 0 0 1-.75-.75V15a.75.75 0 0 0-.75-.75h-2.5A.75.75 0 0 0 9.5 15v6.25a.75.75 0 0 1-.75.75H5.5a2 2 0 0 1-2-2v-7.31l-.9.9a.75.75 0 1 1-1.06-1.06l8.69-8.69Z"/>
        </svg>
        <span class="font-semibold">Study Trainer</span>
      </button>
      <div class="flex items-center gap-2">
        <button id="darkToggle" class="px-3 py-1.5 rounded-lg border border-zinc-200 dark:border-zinc-700 text-sm hover:bg-zinc-100 dark:hover:bg-zinc-800" title="Toggle theme (T)">Toggle Theme</button>
      </div>
    </div>
  </header>

  <main id="app" class="max-w-5xl mx-auto px-4 py-6">
    <!-- Content injected by JS router -->
  </main>

  <footer class="max-w-5xl mx-auto px-4 py-10 text-center text-xs text-zinc-500">
    <p>Swipe left = "Don‚Äôt know", right = "I know". Keyboard: ‚Üê / ‚Üí, Space = reveal, H = home, T = theme.</p>
  </footer>

  <script>
    /*************************
     * Utility & State
     *************************/
    const $ = (sel, el=document) => el.querySelector(sel);
    const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));

    const STORAGE_KEYS = {
      theme: 'trainer.theme',
      progress: (courseId, chapterId, mode) => `trainer.progress.${courseId}.${chapterId}.${mode}`,
      known:   (courseId, chapterId) => `trainer.known.${courseId}.${chapterId}`
    };

    function setTheme(dark) {
      const root = document.documentElement;
      if (dark) { root.classList.add('dark'); localStorage.setItem(STORAGE_KEYS.theme, 'dark'); }
      else { root.classList.remove('dark'); localStorage.setItem(STORAGE_KEYS.theme, 'light'); }
    }
    setTheme(localStorage.getItem(STORAGE_KEYS.theme) === 'dark');

    const State = {
      data: null,
      view: 'home',
      params: {}
    };

    let quiz = null;           // active quiz session object (only when in /quiz route)
    window.quiz = null;        // for inline handlers (we set this when quiz is created)

    const SAMPLE_CHAPTERS = {
      courses: [
        {
          id: 'sample-course',
          name: 'Sample Course',
          chapters: [
            {
              id: 'sample-chapter',
              name: 'Sample Chapter',
              items: [
                { q: 'Add your own chapters in chapters.md', a: 'Put chapters.md next to index.html on GitHub Pages.' }
              ]
            }
          ]
        }
      ]
    };

    /*************************
     * chapters.md parser
     *************************/
    function slugify(s='') {
      return s.toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-');
    }
    function parseBracketId(line) {
      const m = line.match(/\[([^\]]+)\]\s*$/);
      return m ? m[1].trim() : null;
    }
    function stripBracketId(line) {
      return line.replace(/\s*\[[^\]]+\]\s*$/, '').trim();
    }

    function parseChaptersMD(text) {
      const lines = text.replace(/\r\n/g, '\n').split('\n');

      const data = { courses: [] };
      let course = null;
      let chapter = null;

      let cur = null;   // current card
      let field = null; // "q" | "a" | "img"

      function ensureCourse(name, idHint) {
        const id = idHint || slugify(name);
        let c = data.courses.find(x => x.id === id);
        if (!c) {
          c = { id, name, chapters: [] };
          data.courses.push(c);
        }
        return c;
      }

      function ensureChapter(c, name, idHint) {
        const id = idHint || slugify(name);
        let ch = c.chapters.find(x => x.id === id);
        if (!ch) {
          ch = { id, name, items: [] };
          c.chapters.push(ch);
        }
        return ch;
      }

      function flushCard() {
        if (!chapter || !cur) return;
        const q = (cur.q || '').trim();
        const a = (cur.a || '').trim();
        const img = (cur.img || '').trim();
        if (q || a) chapter.items.push({ q, a, img: img || undefined });
        cur = null;
        field = null;
      }

      for (let i = 0; i < lines.length; i++) {
        const raw = lines[i];
        const line = raw.trimEnd();
        const t = line.trim();

        if (!t) {
          if (cur && (field === 'q' || field === 'a')) cur[field] += '\n';
          continue;
        }

        if (t === '---') { flushCard(); continue; }

        if (t.startsWith('# Course:')) {
          flushCard();
          const rest = t.replace('# Course:', '').trim();
          const idHint = parseBracketId(rest);
          const name = stripBracketId(rest);
          course = ensureCourse(name || 'Untitled Course', idHint);
          chapter = null;
          continue;
        }

        if (t.startsWith('## Chapter:')) {
          flushCard();
          if (!course) course = ensureCourse('Untitled Course', 'untitled-course');
          const rest = t.replace('## Chapter:', '').trim();
          const idHint = parseBracketId(rest);
          const name = stripBracketId(rest);
          chapter = ensureChapter(course, name || 'Untitled Chapter', idHint);
          continue;
        }

        if (!cur) cur = { q: '', a: '', img: '' };

        if (t.startsWith('Q:')) { field = 'q'; cur.q += t.replace('Q:', '').trim() + '\n'; continue; }
        if (t.startsWith('A:')) { field = 'a'; cur.a += t.replace('A:', '').trim() + '\n'; continue; }
        if (t.startsWith('IMG:')) { field = 'img'; cur.img = t.replace('IMG:', '').trim(); continue; }

        if (field === 'q' || field === 'a') cur[field] += line + '\n';
      }

      flushCard();
      return data;
    }

    async function loadData() {
      try {
        const res = await fetch('chapters.md', { cache: 'no-store' });
        if (res.ok) {
          const text = await res.text();
          const parsed = parseChaptersMD(text);
          if (parsed && Array.isArray(parsed.courses) && parsed.courses.length) return parsed;
          console.warn('chapters.md parsed but empty/invalid; using SAMPLE_CHAPTERS');
        }
      } catch (e) {
        console.warn('No chapters.md; using SAMPLE_CHAPTERS. Reason:', e.message);
      }
      return SAMPLE_CHAPTERS;
    }

    /*************************
     * Data helpers
     *************************/
    function getCourseById(id) {
      return (State.data?.courses || []).find(c => c.id === id);
    }
    function getChapterById(course, chapterId) {
      return (course?.chapters || []).find(ch => ch.id === chapterId);
    }

    /*************************
     * Rendering
     *************************/
    function renderHome() {
      clearQuizIfLeavingQuiz();

      const courses = State.data.courses || [];
      const cards = courses.map(c => `
        <button class="group rounded-2xl p-4 border border-zinc-200 dark:border-zinc-800 hover:shadow transition bg-white dark:bg-zinc-900"
                onclick="location.hash = '#/course/${c.id}'">
          <div class="aspect-square rounded-xl bg-gradient-to-br from-zinc-100 to-zinc-200 dark:from-zinc-800 dark:to-zinc-700 mb-3 flex items-center justify-center">
            <span class="text-3xl">üìö</span>
          </div>
          <div class="flex items-center justify-between">
            <div>
              <h3 class="font-semibold">${escapeHtml(c.name)}</h3>
              <p class="text-sm text-zinc-500">${c.chapters?.length || 0} chapter(s)</p>
            </div>
            <span class="opacity-0 group-hover:opacity-100 transition">‚Üí</span>
          </div>
        </button>
      `).join('');

      $('#app').innerHTML = `
        <h1 class="text-2xl font-bold mb-4">Choose a course</h1>
        <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">${cards}</div>
      `;
    }

    function renderCourse(courseId) {
      clearQuizIfLeavingQuiz();

      const course = getCourseById(courseId);
      if (!course) return renderNotFound();

      const cards = (course.chapters || []).map(ch => `
        <button class="group rounded-2xl p-4 border border-zinc-200 dark:border-zinc-800 hover:shadow transition bg-white dark:bg-zinc-900"
                onclick="location.hash = '#/chapter/${course.id}/${ch.id}'">
          <div class="aspect-square rounded-xl bg-gradient-to-br from-indigo-100 to-indigo-200 dark:from-indigo-800 dark:to-indigo-700 mb-3 flex items-center justify-center">
            <span class="text-3xl">üóÇÔ∏è</span>
          </div>
          <div class="flex items-center justify-between">
            <div>
              <h3 class="font-semibold">${escapeHtml(ch.name)}</h3>
              <p class="text-sm text-zinc-500">${ch.items?.length || 0} card(s)</p>
            </div>
            <span class="opacity-0 group-hover:opacity-100 transition">‚Üí</span>
          </div>
        </button>
      `).join('');

      $('#app').innerHTML = `
        <div class="flex items-center justify-between mb-4">
          <h1 class="text-2xl font-bold">${escapeHtml(course.name)}</h1>
          <button class="px-3 py-1.5 rounded-lg border border-zinc-200 dark:border-zinc-700 text-sm hover:bg-zinc-100 dark:hover:bg-zinc-800"
                  onclick="location.hash = '#/'">Home</button>
        </div>
        <p class="text-zinc-500 mb-4">Pick a chapter.</p>
        <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">${cards}</div>
      `;
    }

    function renderChapter(courseId, chapterId) {
      clearQuizIfLeavingQuiz();

      const course = getCourseById(courseId);
      const chapter = course && getChapterById(course, chapterId);
      if (!chapter) return renderNotFound();

      $('#app').innerHTML = `
        <div class="flex items-center justify-between mb-6">
          <div>
            <h1 class="text-2xl font-bold">${escapeHtml(chapter.name)}</h1>
            <p class="text-zinc-500">${escapeHtml(course.name)}</p>
          </div>
          <div class="flex items-center gap-2">
            <button class="px-3 py-1.5 rounded-lg border border-zinc-200 dark:border-zinc-700 text-sm hover:bg-zinc-100 dark:hover:bg-zinc-800"
                    onclick="location.hash = '#/course/${course.id}'">Back</button>
            <button class="px-3 py-1.5 rounded-lg border border-zinc-200 dark:border-zinc-700 text-sm hover:bg-zinc-100 dark:hover:bg-zinc-800"
                    onclick="location.hash = '#/'">Home</button>
          </div>
        </div>

        <div class="grid sm:grid-cols-2 gap-4">
          <div class="rounded-2xl p-5 border border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-900">
            <h2 class="font-semibold mb-2">In Order</h2>
            <p class="text-sm text-zinc-500 mb-4">Go through all cards sequentially. Mark known/unknown and track your score.</p>
            <div class="flex items-center gap-2">
              <button class="px-4 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700"
                      onclick="startQuizFromChapter('${course.id}','${chapter.id}','order')">Start</button>
              <label class="inline-flex items-center gap-2 text-sm">
                <input id="shuffle-order" type="checkbox" class="rounded border-zinc-300"/>
                Shuffle
              </label>
            </div>
          </div>

          <div class="rounded-2xl p-5 border border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-900">
            <h2 class="font-semibold mb-2">Training</h2>
            <p class="text-sm text-zinc-500 mb-4">Adaptive practice. Known cards disappear; unknown cards reappear after 4 others.</p>
            <div class="flex items-center gap-2">
              <button class="px-4 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700"
                      onclick="startQuizFromChapter('${course.id}','${chapter.id}','training')">Start</button>
              <label class="inline-flex items-center gap-2 text-sm">
                <input id="shuffle-training" type="checkbox" class="rounded border-zinc-300"/>
                Shuffle
              </label>
              <label class="inline-flex items-center gap-2 text-sm">
                <input id="persist-training" type="checkbox" class="rounded border-zinc-300" checked/>
                Persist progress
              </label>
            </div>
          </div>
        </div>

        ${(chapter.items?.length || 0) === 0
          ? `<p class='mt-6 text-amber-600 text-sm'>This chapter has no cards yet. Add them in <code>chapters.md</code>.</p>`
          : ''}
      `;
    }

    function renderNotFound() {
      clearQuizIfLeavingQuiz();
      $('#app').innerHTML = `
        <div class="text-center py-16">
          <p class="text-5xl mb-2">ü§î</p>
          <p class="text-lg">Not found.</p>
          <button class="mt-4 px-4 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700"
                  onclick="location.hash = '#/'">Go Home</button>
        </div>
      `;
    }

    /*************************
     * Quiz: route-based (fixes back/return)
     *************************/
    function startQuizFromChapter(courseId, chapterId, mode) {
      const shuffle = mode === 'order' ? $('#shuffle-order')?.checked : $('#shuffle-training')?.checked;
      const persist = mode === 'training' ? $('#persist-training')?.checked : false;

      // Put quiz in hash so browser back works properly
      location.hash = `#/quiz/${courseId}/${chapterId}/${mode}?shuffle=${shuffle ? 1 : 0}&persist=${persist ? 1 : 0}`;
    }

    function parseQuery(qs) {
      const q = {};
      if (!qs) return q;
      qs.replace(/^\?/, '').split('&').filter(Boolean).forEach(pair => {
        const [k, v] = pair.split('=');
        q[decodeURIComponent(k)] = decodeURIComponent(v || '');
      });
      return q;
    }

    function ensureQuiz(courseId, chapterId, mode, opts) {
      const course = getCourseById(courseId);
      const chapter = course && getChapterById(course, chapterId);
      if (!chapter) { quiz = null; window.quiz = null; return renderNotFound(); }

      const items = Array.from(chapter.items || []);
      const shuffle = !!opts.shuffle;
      const persist = (mode === 'training') ? !!opts.persist : false;

      if (shuffle) shuffleArray(items);

      quiz = createQuizSession({ course, chapter, items, mode, persist });
      window.quiz = quiz;

      renderQuiz();
    }

    function clearQuizIfLeavingQuiz() {
      // If we leave quiz route, keep things clean + prevent keydown actions
      quiz = null;
      window.quiz = null;
    }

    function createQuizSession({ course, chapter, items, mode, persist }) {
      const key = STORAGE_KEYS.progress(course.id, chapter.id, mode);

      // load saved (only if item hash matches)
      const savedWrap = safeJsonParse(localStorage.getItem(key));
      const itemsHash = hashItems(items);

      // mastered (persisted training)
      let mastered = new Set();
      if (mode === 'training' && persist) {
        const savedKnown = safeJsonParse(localStorage.getItem(STORAGE_KEYS.known(course.id, chapter.id))) || [];
        mastered = new Set(Array.isArray(savedKnown) ? savedKnown : []);
      }

      // initial queue = all cards (minus mastered in training+persist)
      let queue = items.map((it, idx) => ({ idx, it }));
      if (mode === 'training' && persist && mastered.size) {
        queue = queue.filter(c => !mastered.has(c.idx));
      }

      // restore state if compatible
      let state = (savedWrap && savedWrap.itemsHash === itemsHash && savedWrap.state)
        ? savedWrap.state
        : {
            mode,
            courseId: course.id,
            chapterId: chapter.id,
            current: 0,
            reveal: false,
            queue,
            // unique wrong tracking (for score)
            wrongOnce: [],
            // training: store mastered indexes in array for persistence / UI
            mastered: Array.from(mastered)
          };

      // rebuild sets
      let wrongOnceSet = new Set(state.wrongOnce || []);
      mastered = new Set(state.mastered || (Array.from(mastered)));

      function persistState() {
        state.wrongOnce = Array.from(wrongOnceSet);
        state.mastered = Array.from(mastered);

        localStorage.setItem(key, JSON.stringify({ itemsHash, state }));
        if (mode === 'training' && persist) {
          localStorage.setItem(STORAGE_KEYS.known(course.id, chapter.id), JSON.stringify(state.mastered));
        }
      }

      function reset() {
        localStorage.removeItem(key);
        if (mode === 'training') {
          localStorage.removeItem(STORAGE_KEYS.known(course.id, chapter.id));
        }

        wrongOnceSet.clear();
        mastered.clear();

        state = {
          mode,
          courseId: course.id,
          chapterId: chapter.id,
          current: 0,
          reveal: false,
          queue: items.map((it, idx) => ({ idx, it })),
          wrongOnce: [],
          mastered: []
        };

        persistState();
        renderQuiz();
      }

      function getTotals() {
        const total = items.length;

        // In training: progress should ONLY reflect mastered, not "seen"
        const masteredCount = (mode === 'training') ? mastered.size : null;

        // In order: progress can be "seen so far"
        const seenCount = (mode === 'order') ? Math.min(state.current, state.queue.length) : null;

        return { total, masteredCount, seenCount };
      }

      function mark(knownFlag, viaSwipe=false) {
        if (!state.queue.length) return;

        const pos = Math.max(0, Math.min(state.current, state.queue.length - 1));
        const card = state.queue[pos];
        if (!card) return;

        if (knownFlag) {
          if (mode === 'training') {
            // mark mastered
            mastered.add(card.idx);

            // remove ALL occurrences of this card from queue
            state.queue = state.queue.filter(c => c.idx !== card.idx);

            // keep current pointing at next card at same position
            if (pos >= state.queue.length) state.current = state.queue.length; else state.current = pos;
          } else {
            // order mode just advance
            state.current = pos + 1;
          }
        } else {
          // mark wrong (unique)
          wrongOnceSet.add(card.idx);

          if (mode === 'training') {
            // remove current occurrence and reinsert after 4 others
            state.queue.splice(pos, 1);
            const offset = 4;
            const insertPos = Math.min(pos + offset, state.queue.length);
            state.queue.splice(insertPos, 0, card);

            // move to next card (same index pos, now points to next item)
            if (pos >= state.queue.length) state.current = state.queue.length; else state.current = pos;
          } else {
            state.current = pos + 1;
          }
        }

        state.reveal = false;
        if (state.current < 0) state.current = 0;
        if (state.current > state.queue.length) state.current = state.queue.length;

        persistState();
        renderQuiz(knownFlag ? (viaSwipe ? 'right' : null) : (viaSwipe ? 'left' : null));
      }

      function reveal() {
        state.reveal = !state.reveal;
        persistState();
        renderQuiz();
      }

      return {
        state,
        mark,
        reveal,
        reset,
        persistState,
        getTotals,
        _sets: { wrongOnceSet, mastered }
      };
    }
    
    function renderQuiz(swipedDirection = null) {
      const { state, uniqueSeenCount } = quiz;
      const course = getCourseById(state.courseId);
      const chapter = getChapterById(course, state.chapterId);

      const total = (chapter.items || []).length;
      const seen = uniqueSeenCount();
      const remaining = total - quiz._sets.knownOnceSet.size;

      let content = '';
      if (!remaining && state.mode === 'training') {
        content = `<div class="text-center py-10">
          <p class="text-5xl mb-3">üéâ</p>
          <p class="text-lg font-semibold mb-1">Training complete</p>
          <p class="text-sm text-zinc-500 mb-6">You marked all cards as known.</p>
          <div class="flex items-center justify-center gap-2">
            <button class="px-4 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700" onclick="location.hash = '#/chapter/${course.id}/${chapter.id}'">Back to chapter</button>
            <button class="px-4 py-2 rounded-xl border border-zinc-200 dark:border-zinc-700" onclick="quiz.reset()">Reset</button>
          </div>
        </div>`;
      } else if (state.mode === 'order' && state.current >= state.queue.length) {
        content = `<div class="text-center py-10">
          <p class="text-5xl mb-3">‚úÖ</p>
          <p class="text-lg font-semibold mb-1">End of deck</p>
          <p class="text-sm text-zinc-500 mb-4">Score: <b>${state.correct}</b> known, <b>${state.wrong}</b> unknown</p>
          <div class="flex items-center justify-center gap-2">
            <button class="px-4 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700" onclick="quiz.reset()">Restart</button>
            <button class="px-4 py-2 rounded-xl border border-zinc-200 dark:border-zinc-700" onclick="location.hash = '#/chapter/${course.id}/${chapter.id}'">Back</button>
          </div>
        </div>`;
      } else {
        const card = state.queue[state.current];
        const q = card?.it?.q || '(No question)';
        const a = card?.it?.a || '(No answer)';
        const img = card?.it?.img || null;

        content = `
        <div class="flex flex-col gap-4">
          <div class="flex items-center justify-between">
            <div>
              <h1 class="text-xl font-bold">${escapeHtml(chapter.name)} <span class="text-sm font-normal text-zinc-500">(${escapeHtml(course.name)})</span></h1>
              <p class="text-sm text-zinc-500">Mode: <b>${state.mode === 'order' ? 'In Order' : 'Training'}</b></p>
            </div>
            <div class="flex items-center gap-2 text-sm">
              <span class="px-2 py-1 rounded bg-green-600/10 text-green-700 dark:text-green-400">Known: ${state.correct}</span>
              <span class="px-2 py-1 rounded bg-rose-600/10 text-rose-700 dark:text-rose-400">Unknown: ${state.wrong}</span>
              <span class="px-2 py-1 rounded bg-zinc-600/10">Remaining: ${remaining}</span>
            </div>
          </div>

          <div class="w-full h-2 bg-zinc-200 dark:bg-zinc-800 rounded-full overflow-hidden">
            <div class="h-full bg-indigo-600 progress-fill" style="width: ${(total ? (seen/total*100) : 0).toFixed(1)}%"></div>
          </div>

          <div id="card" class="relative rounded-2xl border border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 shadow p-4 md:p-6 select-none will-change-transform">
            <div class="badge badge-left">Don‚Äôt know</div>
            <div class="badge badge-right">I know</div>
            ${img ? `<img src="${escapeAttr(img)}" alt="" class="w-full max-h-56 object-contain rounded-xl mb-3">` : ''}
            <div class="mb-2 text-sm uppercase tracking-wide text-zinc-500">Question</div>
            <div class="text-lg md:text-xl font-medium whitespace-pre-wrap">${escapeHtml(q)}</div>
            <div class="mt-4 border-t border-zinc-200 dark:border-zinc-800 pt-4">
              <div class="flex items-center justify-between mb-2">
                <div class="text-sm uppercase tracking-wide text-zinc-500">Answer</div>
                <button id="revealBtn" class="text-sm px-3 py-1.5 rounded-lg border border-zinc-200 dark:border-zinc-700 hover:bg-zinc-100 dark:hover:bg-zinc-800">${state.reveal ? 'Hide' : 'Reveal'} (Space)</button>
              </div>
              <div id="answer" class="text-base md:text-lg whitespace-pre-wrap ${state.reveal ? '' : 'blur-sm select-none'}">${escapeHtml(a)}</div>
            </div>
          </div>

          <div class="grid grid-cols-2 gap-3">
            <button id="btnNo" class="flex items-center justify-center gap-2 py-3 rounded-xl bg-rose-600 text-white hover:bg-rose-700">
              <span>‚Üê Don‚Äôt know</span>
            </button>
            <button id="btnYes" class="flex items-center justify-center gap-2 py-3 rounded-xl bg-green-600 text-white hover:bg-green-700">
              <span>I know ‚Üí</span>
            </button>
          </div>

          <div class="flex items-center justify-between text-xs text-zinc-500">
            <div>Hotkeys: ‚Üê / ‚Üí to mark ‚Ä¢ Space to reveal ‚Ä¢ H = Home ‚Ä¢ T = Theme</div>
            <div class="flex items-center gap-2">
              <button id="btnReset" class="px-2 py-1 rounded border border-zinc-200 dark:border-zinc-700">Reset</button>
            </div>
          </div>
        </div>`;
      }

      $('#app').innerHTML = content;

      const cardEl = $('#card');
      if (cardEl && swipedDirection) {
        cardEl.classList.add(swipedDirection === 'left' ? 'swipe-left' : 'swipe-right');
        setTimeout(() => { cardEl?.classList.remove('swipe-left','swipe-right'); }, 230);
      }

      $('#revealBtn')?.addEventListener('click', () => quiz.reveal());
      $('#btnNo')?.addEventListener('click', () => quiz.mark(false));
      $('#btnYes')?.addEventListener('click', () => quiz.mark(true));
      $('#btnReset')?.addEventListener('click', () => quiz.reset());

      const ans = $('#answer');
      if (ans) {
        ans.addEventListener('click', (e) => { e.stopPropagation(); quiz.reveal(); });
        ans.addEventListener('mousedown', (e) => e.stopPropagation());
        ans.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
      }

      if (cardEl) initSwipePreview(cardEl, {
        onLeft: () => quiz.mark(false, true),
        onRight: () => quiz.mark(true, true)
      });
    }

    /*************************
     * Router
     *************************/
    function route() {
      const hash = location.hash.replace(/^#\/?/, '');
      const parts = hash.split('/').filter(Boolean);
      if (!parts.length) { State.view = 'home'; State.params = {}; return renderHome(); }

      if (parts[0] === 'course' && parts[1]) {
        State.view = 'course'; State.params = { courseId: parts[1] }; return renderCourse(parts[1]);
      }
      if (parts[0] === 'chapter' && parts[1] && parts[2]) {
        State.view = 'chapter'; State.params = { courseId: parts[1], chapterId: parts[2] }; return renderChapter(parts[1], parts[2]);
      }
      return renderNotFound();
    }

    /*************************
    * Events & Init
    *************************/
    $('#homeBtn').addEventListener('click', () => location.hash = '#/');
    $('#darkToggle').addEventListener('click', () => setTheme(!document.documentElement.classList.contains('dark')));

    document.addEventListener('keydown', (e) => {
      if (e.key === 'h' || e.key === 'H') { location.hash = '#/'; }
      if (e.key === 't' || e.key === 'T') { setTheme(!document.documentElement.classList.contains('dark')); }
      if (!quiz) return;
      if (e.code === 'Space') { e.preventDefault(); quiz.reveal(); }
      if (e.key === 'ArrowLeft')  { e.preventDefault(); quiz.mark(false); }
      if (e.key === 'ArrowRight') { e.preventDefault(); quiz.mark(true); }
    });

    // Swipe with live drag preview
    function initSwipePreview(el, { onLeft, onRight }) {
      let startX = 0, startY = 0, dragging = false;
      let lastDX = 0;
      const badgeL = el.querySelector('.badge-left');
      const badgeR = el.querySelector('.badge-right');

      const commitThreshold = Math.max(60, window.innerWidth * 0.18);

      function setPreview(dx, dy) {
        const damp = Math.min(1, Math.abs(dx) / commitThreshold);
        const rot = (dx / 20);
        el.style.transform = `translateX(${dx}px) rotate(${rot}deg)`;
        el.classList.add('dragging');

        if (badgeL && badgeR) {
          if (dx < 0) {
            badgeL.style.opacity = Math.min(1, damp * 1.2);
            badgeL.style.transform = `scale(${0.95 + 0.05*damp})`;
            badgeR.style.opacity = 0; badgeR.style.transform = 'scale(0.95)';
          } else if (dx > 0) {
            badgeR.style.opacity = Math.min(1, damp * 1.2);
            badgeR.style.transform = `scale(${0.95 + 0.05*damp})`;
            badgeL.style.opacity = 0; badgeL.style.transform = 'scale(0.95)';
          } else {
            badgeL.style.opacity = 0; badgeR.style.opacity = 0;
          }
        }
      }

      function resetPreview() {
        el.classList.remove('dragging');
        el.style.transition = 'transform 160ms ease';
        el.style.transform = '';
        setTimeout(() => { el.style.transition = ''; }, 170);
        if (badgeL && badgeR) { badgeL.style.opacity = 0; badgeR.style.opacity = 0; }
      }

      el.addEventListener('touchstart', (e) => {
        const t = e.touches[0]; startX = t.clientX; startY = t.clientY; dragging = true; lastDX = 0;
      }, { passive: true });

      el.addEventListener('touchmove', (e) => {
        if (!dragging) return;
        const t = e.touches[0];
        const dx = t.clientX - startX; const dy = t.clientY - startY;
        if (Math.abs(dy) > Math.abs(dx) && Math.abs(dx) < 10) return;
        lastDX = dx;
        setPreview(dx, dy);
      }, { passive: true });

      el.addEventListener('touchend', () => {
        if (!dragging) return; dragging = false;
        const dx = lastDX;
        if (Math.abs(dx) > commitThreshold) {
          if (dx < 0) onLeft && onLeft(); else onRight && onRight();
        } else {
          resetPreview();
        }
      });

      // Mouse support
      let mouseDown = false;
      el.addEventListener('mousedown', (e) => { mouseDown = true; startX = e.clientX; startY = e.clientY; });
      document.addEventListener('mousemove', (e) => {
        if (!mouseDown) return;
        const dx = e.clientX - startX; const dy = e.clientY - startY;
        lastDX = dx; setPreview(dx, dy);
      });
      document.addEventListener('mouseup', () => {
        if (!mouseDown) return; mouseDown = false;
        const dx = lastDX;
        if (Math.abs(dx) > commitThreshold) {
          if (dx < 0) onLeft && onLeft(); else onRight && onRight();
        } else {
          resetPreview();
        }
      });
    }

    // Helpers
    function escapeHtml(str='') { return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[s])); }
    function escapeAttr(str='') { return String(str).replace(/"/g, '&quot;'); }
    function shuffleArray(arr) { for (let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
    function hashItems(items){
      const s = items.map(it => `${it.q}|${it.a}|${it.img||''}`).join('\u0001');
      let h=0; for (let i=0;i<s.length;i++){ h=(h*31 + s.charCodeAt(i))|0; } return h;
    }

    // Boot
    (async function init(){
      State.data = await loadData();
      route();
      window.addEventListener('hashchange', route);
    })();
  </script>
</body>
</html>
