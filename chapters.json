{
  "courses": [
    {
      "id": "comp-arch",
      "name": "Computer Architectures",
      "chapters": [
        {

          "id": "arithmetic",
          "name": "Arithmetic",
          "items": [
            { "q": "What does the ALU do, and what data types can it handle?", "a": "Executes arithmetic/logic; always integers, and floating-point via an on-chip FPU or separate coprocessor." },
            { "q": "Which two signed integer representations are covered?", "a": "Sign-magnitude and two’s complement." },
            { "q": "Why is two’s complement preferred over sign-magnitude?", "a": "Single zero, uniform add/sub logic (no special sign handling)." },
            { "q": "How do you negate a two’s-complement value?", "a": "Bitwise NOT then +1 (to LSB)." },
            { "q": "Give the 8-bit range for two’s complement.", "a": "−128 (1000 0000) to +127 (0111 1111)." },
            { "q": "What happens when negating −128 in 8-bit two’s complement?", "a": "It stays −128 (overflow case); sign should flip but cannot." },
            { "q": "How do you sign-extend when widening?", "a": "Copy the sign bit: pad with 0s if positive, 1s if negative." },
            { "q": "Rule shown on slides for detecting overflow in add/sub?", "a": "Monitor the sign bit — overflow if it changes unexpectedly." },
            { "q": "How is subtraction implemented in hardware?", "a": "a − b = a + (two’s complement of b); only need adder + complementer." },
            { "q": "Why can one adder unit do both add and sub?", "a": "Because subtraction is addition with complemented subtrahend." },
            { "q": "What is the 'schoolbook' unsigned binary multiplication method?", "a": "For each 1 in multiplier → add shifted multiplicand; for 0 → add 0; sum partial products; result is double-length." },
            { "q": "How to handle signed multiplication (simple way)?", "a": "Convert to positive, multiply, negate if signs differ." },
            { "q": "What algorithm handles signed multiplication efficiently?", "a": "Booth’s algorithm." },
            { "q": "Why is Booth’s algorithm useful?", "a": "Reduces additions for runs of 1s in the multiplier (efficient signed multiply)." },
            { "q": "What’s the basis of unsigned binary division?", "a": "Long-division style: shift, subtract, set quotient bits; track remainder." },
            { "q": "Why are signed divisions tricky?", "a": "Extra complexity handling signs and edge cases; algorithm given for unsigned with flowchart." },
            { "q": "Write the general floating-point form used.", "a": "± (significand) × 2^(exponent)." },
            { "q": "What does normalization do?", "a": "Adjust exponent so mantissa MSB is 1; that leading 1 can be implicit (not stored)." },
            { "q": "How are signs/exponents stored in FP (per slides)?", "a": "Mantissa in two’s complement; exponent in excess/bias notation (example: excess-128)." },
            { "q": "What FP range/precision figures are highlighted for 32-bit?", "a": "~±2^256 (≈1.5×10^77) range; ~2^−23 precision ≈ 1.2×10^−7 (~6 decimal digits)." },
            { "q": "High-level FP add/sub procedure?", "a": "Check zeros → align significands (adjust exponents) → add/sub → normalize." },
            { "q": "High-level FP mul/div procedure?", "a": "Check zeros → add/sub exponents → mul/div significands → normalize → round (use double-length intermediates)." },
            { "q": "Which FP standard is referenced?", "a": "IEEE-754 (32/64-bit; extended formats for intermediates)." },
            { "q": "Example of binary fixed-point from slides?", "a": "1001.1010₂ = 9.625₁₀." },
            { "q": "Show partial-product pattern for 1011₂ × 1101₂.", "a": "1011, 0000, 1011, 1011 → product 1000 1111₂ (143₁₀), double-length." },
            { "q": "In unsigned long division, what do partial remainders track?", "a": "The running remainder after each subtract/shift step that drives the next quotient bit." },
            { "q": "Convert −18₁₀ to 8-bit two’s complement.", "a": "+18 = 0001 0010 → invert = 1110 1101 → +1 = 1110 1110." },
            { "q": "Sign-extend 8-bit 1001 0010₂ to 16-bit.", "a": "Negative → pad with 1s: 1111 1111 1001 0010." },
            { "q": "Why is multiply result 'double-length'?", "a": "n-bit × n-bit can require up to 2n bits (sum of shifted partial products)." },
            { "q": "Booth trigger condition (conceptual)?", "a": "Encodes runs of 1s in the multiplier to reduce adds (handle 10/01 transitions efficiently)." },
            { "q": "Core steps for unsigned division?", "a": "Align divisor via shifts → compare/subtract → set quotient bit → iterate → final remainder." },
            { "q": "What does excess-128 mean on an 8-bit exponent?", "a": "Stored exponent = true exponent + 128." },
            { "q": "Why keep intermediate FP results in double length?", "a": "To avoid precision loss before final rounding/normalization." },
            { "q": "First step when adding FP numbers with different exponents?", "a": "Shift the smaller significand to align exponents." }
          ]
        },
        {
        "id": "internal-memory",
        "name": "Internal Memory",
        "items": [
            { "q": "Explain DRAM vs. SRAM in terms of storage mechanism, speed, density, and cost.", "a": "DRAM: stores bits as charge in capacitors, needs periodic refresh, slower, higher density, cheaper. SRAM: stores bits in flip-flops, no refresh, faster, lower density, more expensive." },
            { "q": "Why is DRAM essentially analogue in nature?", "a": "Because it stores charge levels on a capacitor that must be sensed and compared to a reference to determine if it's a 0 or 1." },
            { "q": "Why is DRAM read destructive?", "a": "Reading discharges the capacitor, so the stored data must be rewritten after each read." },
            { "q": "What is the function of the sense amplifier in DRAM?", "a": "Detects tiny voltage differences on the bitline caused by the cell and amplifies them to full logic levels, also restoring the cell’s charge." },
            { "q": "Explain the concept of row and column multiplexing in DRAM.", "a": "DRAM uses the same address pins for row and column addresses; RAS selects the row, CAS selects the column, reducing pin count." },
            { "q": "Why is refresh required for DRAM?", "a": "Charge leaks over time from capacitors; refresh restores charge to prevent data loss." },
            { "q": "Describe the DRAM refresh cycle.", "a": "Each row is read by the sense amplifier (restoring data) and written back before charge decays." },
            { "q": "What is the difference between asynchronous DRAM and SDRAM?", "a": "Asynchronous DRAM is not tied to a clock, accesses occur in fixed sequences; SDRAM is synchronized to the system clock, enabling burst transfers." },
            { "q": "Why is SDRAM faster than conventional DRAM?", "a": "Synchronous operation with CPU clock, pipelined commands, and burst transfers reduce latency per word." },
            { "q": "What is DDR SDRAM and how does it improve performance?", "a": "Double Data Rate SDRAM transfers data on both rising and falling edges of the clock, doubling throughput without increasing clock frequency." },
            { "q": "What is the prefetch architecture in DDR?", "a": "The number of bits fetched internally per read command; DDR2 = 4-bit, DDR3 = 8-bit prefetch." },
            { "q": "What improvement does DDR2 have over DDR?", "a": "Higher speeds, lower voltage (1.8V vs 2.5V), improved signaling and prefetching." },
            { "q": "What improvement does DDR3 have over DDR2?", "a": "Even higher speeds, lower voltage (1.5V), improved power efficiency, larger prefetch." },
            { "q": "What is memory interleaving?", "a": "Splitting memory into multiple banks and accessing them in parallel to increase effective throughput and hide latency." },
            { "q": "What is ECC memory and what can it correct?", "a": "Error-Correcting Code memory detects and corrects single-bit errors and detects (but cannot correct) double-bit errors (SECDED)." },
            { "q": "Difference between hard failure and soft error in memory.", "a": "Hard failure is a permanent defect in the memory cell or circuit. Soft error is a temporary bit flip caused by environmental factors like cosmic rays." },
            { "q": "List ROM types in order of least to most rewritable.", "a": "Mask ROM → PROM → EPROM → EEPROM → Flash." },
            { "q": "How is an EPROM erased?", "a": "Using ultraviolet light through a quartz window to discharge the floating gates." },
            { "q": "How is EEPROM erased?", "a": "Electrically, allowing selective byte erasure and rewriting." },
            { "q": "Why is SRAM used for cache memory?", "a": "Extremely low latency and high-speed random access, no refresh requirement." },
            { "q": "Order the memory hierarchy from fastest to slowest.", "a": "Registers → L1 cache → L2 cache → L3 cache → DRAM → SSD/HDD." },
            { "q": "Difference between NOR and NAND flash.", "a": "NOR: direct random access, good for code execution, more expensive, lower density. NAND: faster for sequential data, higher density, lower cost, requires page/block operations." },
            { "q": "Define a flash memory page and block.", "a": "Page: smallest read/write unit. Block: group of pages, smallest erase unit." },
            { "q": "Why must flash memory be erased before rewriting?", "a": "Because flash stores charge on a floating gate; erasure resets all cells in a block to 1 before programming new data." },
            { "q": "Compare SLC, MLC, and TLC flash.", "a": "SLC: 1 bit/cell, fastest, most durable, most expensive. MLC: 2 bits/cell, balanced cost and performance. TLC: 3 bits/cell, cheapest, lowest endurance and speed." },
            { "q": "What is the TRIM command in SSDs?", "a": "Tells the SSD which data blocks are no longer needed, allowing the controller to erase them in advance for faster future writes." },
            { "q": "What is wear leveling in flash memory?", "a": "A technique to distribute write/erase cycles evenly across all blocks to extend lifespan." },
            { "q": "What is the main storage medium in SSDs?", "a": "NAND flash memory cells." },
            { "q": "What does the SSD controller do?", "a": "Manages mapping logical to physical addresses, wear leveling, garbage collection, error correction, and bad block management." },
            { "q": "What is garbage collection in SSDs?", "a": "The process of consolidating valid data and erasing unused blocks to make space for new writes." },
            { "q": "What is write amplification?", "a": "The ratio of physical writes to host writes; occurs when extra writes are needed due to block erasures and data movement." },
            { "q": "Why does an SSD slow down when nearly full?", "a": "Less free space means more data movement during writes, increasing latency." },
            { "q": "How do SSDs handle bad blocks?", "a": "By marking them as unusable and remapping data to spare blocks using the controller." },
            { "q": "Why are sequential writes generally faster than random writes in SSDs?", "a": "Because they can be written in large continuous chunks, minimizing block erases and data movement." },
            { "q": "How does over-provisioning improve SSD performance?", "a": "It reserves extra flash space for the controller to manage wear leveling and garbage collection more efficiently." }
        ]
        },
        {
        "id": "external-memory",
        "name": "External Memory",
        "items": [
            { "q": "List the three main types of external memory covered in the course.", "a": "Magnetic disk, optical storage (CD/DVD/Blu-ray), and magnetic tape." },
            { "q": "Why is glass now preferred over aluminium for magnetic disk substrates?", "a": "Glass offers improved surface uniformity (reliability), fewer defects (reduced errors), supports lower flying heights, better stiffness, and higher shock resistance." },
            { "q": "Describe the basic read/write process on a magnetic disk.", "a": "Write: current through the coil produces a magnetic field that changes polarity on the disk surface. Read (traditional): moving magnetic field induces current in the coil. Read (modern): separate magnetoresistive head detects changes in resistance due to magnetic field direction." },
            { "q": "What is the difference between CAV and zone bit recording?", "a": "CAV rotates at constant speed, same bits per track (outer tracks waste space). Zone bit recording uses zones with more bits per outer track to increase capacity." },
            { "q": "What are tracks, sectors, and cylinders?", "a": "Tracks: concentric circles on the platter. Sectors: smallest addressable storage unit within a track. Cylinder: all tracks aligned vertically across platters." },
            { "q": "Explain the difference between fixed-head and movable-head disks.", "a": "Fixed-head: one head per track, no head movement. Movable-head: one head per platter side, mounted on an arm that moves between tracks." },
            { "q": "Why use multiple platters in a hard drive?", "a": "To increase capacity and performance; aligned heads form cylinders so data can be read/written across platters with less head movement." },
            { "q": "Define seek time, rotational latency, and access time.", "a": "Seek time: time to position head over correct track. Rotational latency: time waiting for desired sector to rotate under head. Access time = seek + latency." },
            { "q": "What is RAID and why is it used?", "a": "Redundant Array of Independent/Inexpensive Disks; combines multiple physical disks for higher speed, capacity, and/or fault tolerance using striping, mirroring, or parity." },
            { "q": "Summarize RAID 0, 1, 5, and 6.", "a": "RAID 0: striped, no redundancy, max speed. RAID 1: mirrored, high reliability, costlier. RAID 5: striped with distributed parity, balanced performance/reliability. RAID 6: like RAID 5 but with two parity blocks for higher fault tolerance." },
            { "q": "Why is RAID 2 rarely used?", "a": "It uses bit-level striping with multiple dedicated parity disks for Hamming code error correction, making it expensive and overly redundant." },
            { "q": "Explain the principle of optical storage (CD/DVD).", "a": "Data stored as pits and lands on a reflective surface; read by laser detecting changes in reflectivity. Smaller pits and shorter wavelength lasers increase capacity." },
            { "q": "What does 'constant linear velocity' mean in CD drives?", "a": "Disc speed varies so that data passes under the laser at a constant rate, ensuring uniform bit density across the spiral track." },
            { "q": "What’s the capacity difference between DVD and Blu-ray single layers?", "a": "DVD single layer: ~4.7 GB; Blu-ray single layer: ~25 GB." },
            { "q": "Why can random access be slow on CD-ROMs?", "a": "Requires moving the head to approximate position, adjusting rotational speed, and reading addresses before reaching target data." },
            { "q": "What is the main advantage of CD-RW over CD-R?", "a": "CD-RW can be erased and rewritten using phase-change materials, while CD-R is write-once." },
            { "q": "Why did Blu-ray achieve higher capacity than DVD?", "a": "Uses a shorter wavelength blue-violet laser, smaller pits, and a data layer closer to the surface for tighter focus and less distortion." },
            { "q": "What is magnetic tape mainly used for today?", "a": "Backup and archival storage due to low cost per bit and high capacity, despite slow access times." },
            { "q": "Explain 'serial access' in the context of magnetic tape.", "a": "Data can only be read sequentially from the start to the target location, unlike random access on disks." },
            { "q": "What is LTO and why is it important?", "a": "Linear Tape-Open: an open-standard high-capacity magnetic tape format for enterprise backup, evolving through multiple generations with increasing capacity and transfer rates." }
        ]
        },
        {
          "id": "instruction-cycles",
          "name": "Instruction Cycles",
          "items": [
            { "q": "Define the instruction cycle at a high level.", "a": "The recurring sequence the CPU performs for each instruction: Fetch (get the next instruction), Decode (interpret opcode/operands), Execute (perform the action), plus an optional Interrupt cycle to service pending interrupts between instructions." },
            { "q": "List the registers most directly involved in the fetch cycle and their roles.", "a": "PC (Program Counter): holds address of next instruction. MAR (Memory Address Register): receives the address to access memory. MBR/MDR (Memory Buffer/Data Register): holds data read from or written to memory. IR (Instruction Register): latches the fetched instruction for decode/execute." },
            { "q": "Walk through the standard fetch sequence as micro-operations.", "a": "1) MAR ← PC; 2) Memory read; 3) IR ← MBR; 4) PC ← PC + 1 (or + instruction length). Now the instruction in IR is ready for decoding." },
            { "q": "What happens during the decode phase?", "a": "The control unit interprets the IR’s opcode/format, determines required operand sources/destinations and addressing mode(s), and generates the control signals for the execute phase." },
            { "q": "Name the four broad classes of actions in the execute cycle.", "a": "Processor–memory (load/store), Processor–I/O (I/O read/write), Data processing (ALU operations), and Control (alter sequence via branch/jump/call/return)." },
            { "q": "Explain how a branch instruction alters the basic fetch–execute flow.", "a": "If the branch condition is met, the CPU loads the PC with a new target address (computed from immediate or register/ALU result) instead of the next sequential PC, changing the next fetch location." },
            { "q": "What is an interrupt and why is it used?", "a": "An asynchronous signal/event that diverts normal execution so the CPU can handle conditions like I/O completion, timer ticks, program exceptions, or hardware faults—improving responsiveness and overlap of I/O with computation." },
            { "q": "List common interrupt sources.", "a": "Program (e.g., divide by zero, overflow, illegal opcode), Timer (periodic tick), I/O (device signals completion or service request), and Hardware failure (e.g., parity error)." },
            { "q": "Outline the steps of the interrupt cycle.", "a": "1) CPU checks for pending/enable interrupts; 2) if one is pending, current context is saved (PC, status, key registers); 3) PC is loaded with the interrupt handler’s entry address (via vector or fixed entry); 4) handler executes; 5) context is restored and normal program resumes." },
            { "q": "What is the role of the PSW/flags during an interrupt?", "a": "Interrupt enable/priority bits are examined; status flags and the current mode are saved so the handler can run with appropriate privileges and the original state can be restored." },
            { "q": "Contrast vectored vs. non-vectored interrupts.", "a": "Vectored: the device/priority provides an interrupt vector (address) to jump directly to its specific handler. Non-vectored: the CPU branches to a fixed location; software must poll status to identify the source." },
            { "q": "Explain interrupt masking.", "a": "Software or hardware can disable (mask) certain interrupts to protect critical sections; masked requests remain pending until re-enabled." },
            { "q": "Compare sequential vs nested interrupt handling.", "a": "Sequential: CPU disables further interrupts while servicing one; pending ones are handled afterward. Nested: allows higher-priority interrupts to preempt a lower-priority handler; after servicing, control returns to the preempted handler." },
            { "q": "Why do interrupts improve overall system performance with slow I/O?", "a": "They let the CPU continue executing other tasks while devices operate; when the device finishes, it interrupts the CPU instead of the CPU busy-waiting or polling continuously." },
            { "q": "Define access time for memory and how it affects instruction timing.", "a": "Access time is the latency to complete a memory read/write. Fetch and load/store operations are gated by this latency; long memory or I/O waits stretch the overall instruction cycle unless hidden by caches or overlapped by interrupts/DMA." },
            { "q": "Give two timing scenarios that illustrate the effect of I/O latency on a program.", "a": "Short I/O wait: brief stall before execution continues. Long I/O wait: significant idle time unless overlapped by other work or serviced via interrupts/DMA." },
            { "q": "What state information must be saved on an interrupt and why?", "a": "At minimum: PC (return point), status/flags, and any registers the handler will use. This preserves the interrupted program’s exact state so it resumes correctly after the handler completes." },
            { "q": "Explain the difference between exceptions (synchronous) and interrupts (asynchronous).", "a": "Exceptions are triggered by the current instruction’s execution (e.g., page fault, divide-by-zero); interrupts originate externally and can occur between instructions regardless of the current instruction semantics." },
            { "q": "Describe the top-level CPU–Memory–I/O interconnections relevant to the cycle.", "a": "CPU issues addresses and control signals over buses; memory and I/O modules respond with data or status. The instruction cycle repeatedly uses these interconnects: fetch uses CPU→Memory read; execute may use CPU↔Memory or CPU↔I/O transfers." },
            { "q": "How does the Program Counter (PC) get updated across different instruction types?", "a": "Normally PC ← PC + instruction length at the end of fetch; branches/jumps/calls overwrite PC with a target; returns restore PC from a saved value (e.g., stack/link register)." },
            { "q": "Where do operands live from the CPU’s perspective?", "a": "In registers (fastest), in main memory, or in I/O device buffers. The instruction’s addressing mode indicates where to fetch them from and where to place results." },
            { "q": "Give the micro-operations for a typical load instruction.", "a": "1) MAR ← EffectiveAddress; 2) Memory read; 3) Register_dest ← MBR." },
            { "q": "Give the micro-operations for a typical store instruction.", "a": "1) MAR ← EffectiveAddress; 2) MBR ← Register_src; 3) Memory write." },
            { "q": "Give the micro-operations for a typical ALU instruction (register-register).", "a": "1) ALU_out ← f(Rs, Rt); 2) Rd ← ALU_out; 3) Update flags as needed; PC already advanced in fetch." },
            { "q": "How do addressing modes relate to the instruction cycle?", "a": "During decode/execute, the CPU computes the Effective Address (EA) based on the addressing mode (e.g., immediate, direct, indirect, register, displacement/PC-relative), then performs the operand access via memory or registers." },
            { "q": "Explain PC-relative addressing in the context of the cycle.", "a": "The Effective Address is computed as EA = PC + displacement (often using the PC value after fetch). This supports position-independent code and good locality for branches and data near the code." },
            { "q": "How does stack use appear in the instruction cycle for subroutine calls/returns?", "a": "Call: push return PC (and possibly PSW/registers), then set PC to subroutine address. Return: pop saved PC (and state) to resume execution exactly after the call." },
            { "q": "What is the Instruction Register (IR) and why is it necessary?", "a": "IR holds the current instruction while it’s being decoded and executed, stabilizing the opcode/fields independent of memory timing and allowing the control unit to generate signals." },
            { "q": "Why is an instruction cycle state diagram useful?", "a": "It formalizes states (Fetch, Indirect/EA compute if needed, Execute, Interrupt check/serve) and the transitions between them, clarifying control sequencing and where stalls or interrupts can occur." },
            { "q": "How does the CPU decide when to check for interrupts?", "a": "Typically at well-defined points—most commonly after finishing an instruction (before starting the next fetch). Some architectures also check during specific long operations or at micro-state boundaries." },
            { "q": "What is the effect of disabling interrupts globally?", "a": "All maskable interrupts are deferred; they remain pending until interrupts are re-enabled, ensuring critical sections run atomically but reducing responsiveness." },
            { "q": "What determines the order in which multiple pending interrupts are handled?", "a": "Priority schemes (fixed or programmable). Higher-priority interrupts may either preempt lower-priority ones (nested handling) or be serviced first after the current handler completes (sequential handling)." },
            { "q": "Explain the relationship between the instruction cycle and bus activity.", "a": "Fetch and operand accesses assert addresses and control signals on the address/control buses; data moves on the data bus. The cadence of the instruction cycle determines bus utilization patterns." },
            { "q": "Why do complex instructions (e.g., with memory operands) lengthen the execute phase?", "a": "They may require extra memory cycles (to compute EA, to fetch/store operands) and additional control sequencing compared to simple register-to-register ALU ops." },
            { "q": "How do caches influence the instruction cycle timing?", "a": "Cache hits shorten fetch/load latency dramatically; misses incur main-memory access and stall the cycle until data returns (unless overlapped by out-of-order or prefetching in more advanced CPUs)." },
            { "q": "What is the difference between polling and interrupt-driven I/O in the cycle?", "a": "Polling: CPU repeatedly checks device status during execute, wasting cycles when idle. Interrupt-driven: CPU proceeds with other work; device triggers an interrupt when ready, leading into the interrupt cycle." },
            { "q": "Show the fetch-decode-execute-interrupt loop in pseudocode form.", "a": "loop { IR ← Mem[PC]; PC ← PC + L; decode(IR); execute(IR); if (INT_pending & enabled) { save_context(); PC ← handler_addr; run_handler(); restore_context(); } }" },
            { "q": "Why must the return address be saved before servicing an interrupt?", "a": "So that normal execution can resume at the exact instruction boundary where it was interrupted, preserving program correctness and flow." },
            { "q": "What is the role of the control unit in the instruction cycle?", "a": "It sequences micro-operations, issues control signals to datapath and buses, handles branching decisions, and orchestrates interrupt acknowledgment and context save/restore." },
            { "q": "Explain how DMA interacts with the instruction cycle.", "a": "DMA lets an I/O controller transfer blocks between memory and device without CPU involvement; the CPU’s instruction cycle is momentarily stalled only for bus arbitration, while the transfer proceeds in parallel." },
            { "q": "Why do architectures define privilege levels in relation to interrupts?", "a": "Interrupt handlers often need to access protected resources; entering a privileged mode on interrupt ensures safe access, while user mode prevents applications from executing sensitive operations." },
            { "q": "Differentiate between synchronous control flow changes (branches/calls) and asynchronous ones (interrupts).", "a": "Synchronous changes are dictated by the executing instruction stream; asynchronous changes are triggered by external events and occur between instructions (architecturally)." },
            { "q": "What happens if an interrupt arrives during the fetch of the next instruction?", "a": "Architecturally, most CPUs complete the current instruction (including its fetch) before acknowledging the interrupt; then they enter the interrupt cycle and branch to the handler." },
            { "q": "Give an example of micro-ops for a conditional branch that is taken.", "a": "If condition flag set: PC ← PC + displacement (or PC ← target_reg/ALU result); else PC remains sequential. Control unit sets these based on flags evaluated during execute." },
            { "q": "Why do some architectures include an 'indirect' stage in the instruction cycle?", "a": "If the addressing mode is indirect, an extra memory read is needed to fetch the pointer to the operand before the actual operand access—this can be modeled as an 'indirect' sub-cycle between fetch and execute." },
            { "q": "Summarize the main benefit of structuring execution into well-defined cycles.", "a": "It cleanly separates concerns (fetch vs. execute vs. interrupt handling), simplifies control sequencing and hardware design, and provides clear points for performance optimizations and precise exception handling." }
          ]
        },
        {
          "id": "processor-structure-parallelism",
          "name": "Processor Structure and Parallelism",
          "items": [
            { "q": "What are the five main tasks of a CPU?", "a": "1) Fetch instruction from memory, 2) Decode/interpret instruction, 3) Fetch operands if needed, 4) Execute the instruction, 5) Store results." },
            { "q": "What role do registers play in processor performance?", "a": "Registers are the fastest form of storage, directly accessible by the CPU. They reduce memory access, support instruction execution, and their number and type affect CPU speed." },
            { "q": "Differentiate between general-purpose, data, address, and condition-code registers.", "a": "General-purpose: flexible use for data/addresses. Data registers: hold operands. Address registers: hold memory locations. Condition-code (flags): hold status bits (zero, carry, sign, overflow)." },
            { "q": "What is the Program Status Word (PSW)?", "a": "A collection of bits reflecting CPU state: condition codes (zero, carry, overflow), interrupt enables, execution mode (user/supervisor), and other control bits." },
            { "q": "Why are user mode and supervisor mode necessary?", "a": "User mode restricts execution to non-privileged instructions to protect the OS and hardware. Supervisor mode allows privileged operations like I/O control, memory management, and interrupt handling." },
            { "q": "What are the stages of instruction pipelining?", "a": "Common stages: 1) Fetch, 2) Decode, 3) Execute, 4) Memory access, 5) Write-back. Not all processors use all five, but the idea is to overlap execution." },
            { "q": "What is the main goal of pipelining?", "a": "To increase instruction throughput by overlapping stages of multiple instructions, so multiple instructions are processed simultaneously." },
            { "q": "What are pipeline hazards?", "a": "Situations that stall or disrupt pipeline flow: 1) Structural hazards (resource conflicts), 2) Data hazards (instruction depends on previous result), 3) Control hazards (branch/jump instructions)." },
            { "q": "Give an example of a structural hazard.", "a": "If two pipeline stages need the same memory port in the same cycle, the hardware cannot serve both, causing a stall." },
            { "q": "Give an example of a data hazard.", "a": "Instruction 2 uses the result of Instruction 1 before it has been written back. Example: I1: R1 ← R2 + R3; I2: R4 ← R1 + R5. I2 depends on I1’s result." },
            { "q": "Give an example of a control hazard.", "a": "A conditional branch whose target is not known until after execution. The pipeline may fetch wrong instructions and need to flush them." },
            { "q": "How are data hazards solved?", "a": "1) Forwarding/bypassing (send result directly to dependent instruction), 2) Pipeline stalling (insert bubbles), 3) Compiler scheduling (reorder instructions)." },
            { "q": "How are control hazards solved?", "a": "Techniques: branch prediction (static/dynamic), delayed branching, or pipeline flushing with penalties." },
            { "q": "What is branch prediction?", "a": "A mechanism to guess branch outcomes before resolved. Static prediction uses fixed rules, dynamic prediction uses history. Correct guesses improve performance; mispredictions cause stalls." },
            { "q": "What is a superscalar processor?", "a": "A CPU with multiple execution units that can issue and complete multiple instructions per cycle. Requires ILP, complex scheduling, and hazard detection." },
            { "q": "Explain Instruction-Level Parallelism (ILP).", "a": "ILP is executing independent instructions in parallel within a single core. Exploited by pipelining, superscalar execution, out-of-order execution, and speculation." },
            { "q": "What is out-of-order execution?", "a": "A CPU technique where instructions are executed as soon as operands are available, not strictly in program order, to reduce stalls and maximize ILP." },
            { "q": "What is register renaming and why is it needed?", "a": "A technique to remove false data dependencies (name dependencies) by mapping logical registers to physical ones, allowing more parallel execution." },
            { "q": "Differentiate ILP and TLP.", "a": "ILP: parallelism within a single instruction stream (pipelining, superscalar). TLP: parallelism across multiple threads or processes (multicore, SMT)." },
            { "q": "Summarize Flynn’s taxonomy of computer architectures.", "a": "SISD: single instruction, single data. SIMD: single instruction, multiple data (vector processors, GPUs). MISD: multiple instruction, single data (rare). MIMD: multiple instruction, multiple data (multicore, clusters)." },
            { "q": "Give an example of SIMD parallelism in practice.", "a": "Graphics processing (GPU shaders) where the same instruction is applied to many pixels or data elements in parallel." },
            { "q": "What does Amdahl’s Law state?", "a": "Speedup with p processors = 1 / (f + (1-f)/p), where f is the fraction of serial code. Shows diminishing returns as serial portion dominates." },
            { "q": "If 20% of a program is serial, what is the maximum speedup possible according to Amdahl’s Law?", "a": "Maximum speedup = 1 / 0.2 = 5, even with infinite processors." },
            { "q": "What are the implications of Amdahl’s Law for parallel system design?", "a": "Improving the serial portion is critical; adding more processors only helps if most of the workload is parallelizable." },
            { "q": "What is thread-level parallelism (TLP)?", "a": "Executing multiple independent threads or processes simultaneously, either on multiple cores or interleaved on one core (SMT/hyperthreading)." },
            { "q": "How does multicore architecture exploit TLP?", "a": "By placing multiple independent cores on one chip, allowing true MIMD execution of multiple threads, improving throughput for parallel workloads." },
            { "q": "What is simultaneous multithreading (SMT)?", "a": "Technique where a single core executes multiple threads in the same cycle by sharing functional units, improving utilization of idle resources." },
            { "q": "Differentiate multicore vs. multiprocessor systems.", "a": "Multicore: multiple cores on one chip. Multiprocessor: multiple CPUs (sockets) in one system. Both support MIMD but differ in integration and communication latency." },
            { "q": "What is the difference between strong and weak scaling?", "a": "Strong scaling: fixed problem size, add processors to reduce runtime. Weak scaling: increase problem size proportionally to number of processors." }
          ]
        },
        {
          "id": "cache-memory",
          "name": "Cache Memory",
          "items": [
            { "q": "What is cache memory and why is it important?", "a": "Cache is a small, very fast memory between CPU and main memory. It reduces the average memory access time by storing recently and frequently accessed instructions and data. It exploits locality of reference and allows the CPU to run at near its maximum speed without waiting for slower main memory." },
            { "q": "Explain temporal and spatial locality.", "a": "Temporal locality: recently accessed data is likely to be accessed again soon. Spatial locality: data located near recently accessed addresses is likely to be used soon. Caches exploit both by storing recently used blocks and fetching contiguous memory blocks." },
            { "q": "Define cache hit and cache miss.", "a": "Cache hit: the CPU finds the requested word in cache, leading to a fast access. Cache miss: the word is not in cache and must be fetched from main memory, which is slower." },
            { "q": "What is hit ratio and miss ratio?", "a": "Hit ratio = (cache hits ÷ total accesses). Miss ratio = 1 − hit ratio. High hit ratio means most requests are served quickly from cache, reducing average access time." },
            { "q": "Write the formula for average memory access time (AMAT).", "a": "AMAT = Hit time + (Miss ratio × Miss penalty). For multi-level caches, Miss penalty includes the access time of the next level." },
            { "q": "What is a cache block (line)?", "a": "The unit of data exchanged between main memory and cache. A block contains several consecutive words. This reduces miss rate by exploiting spatial locality." },
            { "q": "Why aren’t larger blocks always better?", "a": "Larger blocks increase miss penalty (more data per transfer), may waste cache space if not all words are used, and can evict other useful blocks, increasing conflict misses." },

            { "q": "What are the three main mapping techniques?", "a": "Direct mapping, fully associative mapping, and set-associative mapping." },
            { "q": "How does direct mapping work?", "a": "Each memory block maps to exactly one cache line (index = block address mod number of lines). It’s simple and fast, but multiple blocks competing for the same line cause conflict misses." },
            { "q": "How does fully associative mapping work?", "a": "Any memory block can be placed in any cache line. Flexible and avoids conflict misses, but requires associative (parallel) search hardware, which is costly and slower." },
            { "q": "How does set-associative mapping work?", "a": "Cache is divided into sets, each with multiple lines (ways). A memory block maps to exactly one set but can be stored in any line of that set. It balances speed and flexibility." },
            { "q": "What does 'n-way set associative' mean?", "a": "Each set has n lines. Example: 4-way set associative means each set has 4 possible places to store a block." },

            { "q": "What are cache replacement policies?", "a": "When a set is full and a new block must be placed, a line must be replaced. Common policies: Least Recently Used (LRU), First-In-First-Out (FIFO), and Random." },
            { "q": "Explain LRU, FIFO, and Random replacement.", "a": "LRU replaces the block that hasn’t been used for the longest time (best performance but hardware-expensive). FIFO replaces the oldest block loaded. Random replaces a randomly chosen block, simple but less optimal." },

            { "q": "What are the two main write policies in caches?", "a": "Write-through and write-back." },
            { "q": "Explain write-through cache.", "a": "Every write updates both cache and main memory. Simple but generates more memory traffic. Often combined with a write buffer to reduce stalls." },
            { "q": "Explain write-back cache.", "a": "Write updates only the cache line and marks it dirty. The main memory is updated only when the dirty block is replaced. Reduces memory traffic but adds complexity." },
            { "q": "What is write-allocate vs no-write-allocate?", "a": "Write-allocate: on a write miss, the block is loaded into cache, then written. No-write-allocate: on a write miss, data is written directly to memory without loading into cache." },

            { "q": "Why do modern CPUs use multi-level caches?", "a": "Because a single large fast cache is impractical. L1 cache is very small and fast, L2 larger but slower, and L3 even larger and often shared. This hierarchy balances access speed and storage capacity." },
            { "q": "What are inclusive and exclusive cache policies?", "a": "Inclusive: all data in L1 is guaranteed to be in L2/L3, simplifying coherence. Exclusive: a block appears in only one level, maximizing effective capacity. Non-inclusive/non-exclusive is also used." },
            { "q": "Give an example of cache hierarchy in a real CPU.", "a": "A modern Intel Core CPU may have 32 KB L1 instruction cache and 32 KB L1 data cache (8-way set associative), a 256 KB private L2 cache, and a shared multi-MB L3 cache." },

            { "q": "What are the main types of cache misses?", "a": "Compulsory misses (first access to a block), conflict misses (due to mapping conflicts), and capacity misses (cache too small to hold working set)." },
            { "q": "Why can conflict misses occur even if cache has free space?", "a": "In direct-mapped or limited set-associative caches, multiple blocks map to the same line or set, forcing replacements." },
            { "q": "How can misses be reduced?", "a": "Increase block size (reduces compulsory misses), increase associativity (reduces conflict misses), or increase cache size (reduces capacity misses)." },

            { "q": "What is the difference between unified and split caches?", "a": "Unified cache stores both instructions and data. Split cache has separate instruction and data caches (Harvard architecture style). Split caches allow parallel instruction/data access but may be less flexible." },

            { "q": "How do caches impact CPU performance?", "a": "They reduce the average memory access time dramatically. Without caches, CPUs would stall frequently waiting for slow main memory. With a high hit ratio, effective CPU speed approaches cache speed." },
            { "q": "Explain the trade-off between hit time and miss rate.", "a": "Smaller caches are faster (low hit time) but have higher miss rates. Larger caches reduce misses but have slower hit time. Designers balance these trade-offs for optimal performance." }
          ]
        }

      ]
    },
    {
  "id": "sensors-actuators",
  "name": "Sensoren & Actuatoren",
  "chapters": [
    {
      "id": "meetsystemen",
      "name": "Meetsystemen",
      "items": [
        { "q": "Wat zijn de vier basiselementen van een meetsysteem?", "a": "1) Sensor (zet stimulus om naar elektrisch signaal). 2) Signaalconditionering (versterken, filteren, level-shiften, galvanische scheiding). 3) Signaalverwerking (digitalisatie/ADC, linearisatie, berekening). 4) Weergave/uitgang (presentatie of besturing)." },
        { "q": "Definieer ‘sensor’ en ‘transducer’.", "a": "Sensor: apparaat dat een stimulus (measurand) ontvangt en met een elektrisch signaal reageert. Transducer: zet een energievorm/grootheid om in een andere (bv. mechanisch → elektrisch) en wordt vaak als voortrap bij een sensor gebruikt." },
        { "q": "Wat is het verschil tussen directe en hybride sensoren?", "a": "Directe sensoren zetten de fysische grootheid rechtstreeks om in een elektrisch signaal. Hybride sensoren vereisen eerst een transducerstap (omzetting van de grootheid) vóór de elektrische detectie." },
        { "q": "Actieve vs. passieve sensoren: geef BEIDE gangbare definities uit de cursus.", "a": "Baeten: actief = genereert eigen elektrisch signaal (thermokoppel, PV-diode), passief = externe bron/excitatie nodig (thermistor, strain gauge). Fraden: passief = geen externe excitatie (meestal directe sensoren), actief = externe voeding nodig (parametrische sensoren die hun eigenschappen wijzigen)." },
        { "q": "Noem belangrijke statische eigenschappen van sensoren.", "a": "Werkingsgebied/bereik, gevoeligheid, offset, resolutie, lineariteit (niet-lineariteit), hysterese, nauwkeurigheid, herhaalbaarheid, reproduceerbaarheid, ruis- en kruisgevoeligheid, drift." },
        { "q": "Verschil tussen resolutie en nauwkeurigheid (met voorbeeld).", "a": "Resolutie: kleinste detecteerbare stap (bv. 0,01 V). Nauwkeurigheid: hoe dicht bij de echte waarde (bv. ±0,1 V). Een systeem kan hoge resolutie hebben maar onnauwkeurig zijn door offset/gain-fouten." },
        { "q": "Wat is niet-lineariteit en hoe rapporteer je ze typisch?", "a": "Maximale afwijking tussen reële en ideale overdrachtskarakteristiek binnen het bereik. Vaak uitgedrukt als absolute fout of als percentage van Full Scale Deflection (FSD)." },
        { "q": "Definieer hysterese en hoe druk je ze uit.", "a": "Geheugeneffect: verschillende uitgangen voor dezelfde ingang afhankelijk van op-/aflopende sweep. Hysterese = max(Δy) tussen op- en afgaande curve, vaak als %FSD." },
        { "q": "Herhaalbaarheid vs. reproduceerbaarheid?", "a": "Herhaalbaarheid: dezelfde operator, zelfde instrument en condities → dezelfde meting. Reproduceerbaarheid: verschillende operatoren, zelfde instrument en condities → zelfde resultaat." },
        { "q": "Wat is kruisgevoeligheid (cross-sensitivity)?", "a": "Output wordt (ongewenst) beïnvloed door andere grootheden dan de doelmeasurand (bv. temperatuur beïnvloedt een druksensor)." },
        { "q": "Wat is het verschil tussen ‘modifying’ en ‘interfering’ effecten?", "a": "Modifying: verandering in gevoeligheid door externe invloed. Interfering: verschuiving van de nul/offset door externe invloed." },
        { "q": "Wat bedoelen we met de ‘error band’ van een meetsysteem?", "a": "Gecombineerde invloed van fouten/ruis binnen een band rond de ideale karakteristiek; kansdichtheidsfunctie (PDF) geeft de waarschijnlijkheid dat output binnen een interval valt." },
        { "q": "Wat is een overdrachtsfunctie in meetsystemen en waarom is de inverse belangrijk?", "a": "Relatie tussen stimulus en elektrisch signaal. De inverse laat toe de stimulus uit het gemeten signaal te reconstrueren (calibratie/linearisatie)." },
        { "q": "Noem dynamische eigenschappen die relevant zijn.", "a": "Vertraging (tijdconstante), faseverschuiving, bandbreedte, resonantiefrequentie, overshoot/settling." },
        { "q": "Wat is ratiometrische meting en waarom is ze nuttig?", "a": "Refereren aan dezelfde voedingsbron voor sensor en brug/versterker zodat multiplicatieve fouten (voedingsvariaties) wegvallen; typisch bij brugschakelingen." },
        { "q": "Leg Thevenin- en Norton-equivalent uit en wanneer je ze gebruikt.", "a": "Thevenin: ideale spanningsbron in serie met impedantie. Norton: ideale stroombron in parallel met impedantie. Beide zijn equivalent (voor lineaire netwerken); keuze hangt af van spannings- of stroomgestuurde analyse." },
        { "q": "Wat is het algemene ‘load effect’ in een meetketen?", "a": "Eindige bron- en belastingsimpedanties beïnvloeden elkaar, waardoor de gemeten spanning/stroom afwijkt t.o.v. het onbelaste geval." },
        { "q": "Potentiometer: uitdrukking voor Vout/Vin met bronweerstand Rs.", "a": "Vout/Vin = α·R / (R + Rs) ≈ α·(1 − Rs/R) voor Rs ≪ R, met α = schuifstand (0…1) en totale potmeterweerstand R." },
        { "q": "Potentiometer: uitdrukking voor Vout/Vin met belastingsweerstand RL.", "a": "Vout/Vin = α·R_L / (R_L + αR − α²R) = α / (1 + αR/R_L − α²R/R_L). Niet-lineariteit neemt toe bij lage RL en is max. rond α ≈ 2/3." },
        { "q": "Welke nadelen hebben klassieke (mechanische) potentiometers?", "a": "Eindige levensduur (slijtage, vuil/corrosie), contactruis (resistieve ‘witte’ ruis), beperkte snelheid en omgevingsgevoeligheid." },
        { "q": "Wat doen ‘sine/cosine’-potentiometers?", "a": "Zetten hoek om naar twee orthogonale spanningen ~sin(θ) en ~cos(θ) voor eenduidige hoekbepaling; nuttig in servo-/richtsystemen." },
        { "q": "Magnetische/inductieve potentiometer: kernidee en voordeel?", "a": "Gebruikt velddeformatie en veldgevoelige weerstanden (Gauss-elementen). Voordeel: geen mechanisch contact → minder slijtage/gevoeligheid voor stof." },
        { "q": "Strain gauge: basisformule en gauge factor (GF).", "a": "R = ρ·l/A. Differentieer: dR/R = dρ/ρ + dl/l − dA/A. In metalen is dρ/ρ ≈ 0 → dR/R ≈ 2·(dl/l) dus GF ≈ 2. In halfgeleiders GF ≈ 100 maar sterk T-afhankelijk." },
        { "q": "Waarom gebruik je vaak een Wheatstonebrug voor strain gauges?", "a": "Differentieel en ratiometrisch → onderdrukt offset/ruis/voedingsvariaties; met temp.-compensatie (actief/passief element) verminder je drift." },
        { "q": "Wat is het voordeel van een ‘actieve’ brugconfiguratie bij gauges?", "a": "Gauge in terugkoppellus om stroom/uitgang te stabiliseren (hoge gevoeligheid), wel ongebalanceerd gedrag en aandacht voor stabiliteit nodig." },
        { "q": "In welke eenheid druk je rek vaak uit en waarom?", "a": "µstrain (με = 10⁻⁶). Omdat rek in technische toepassingen zeer klein is en zo praktisch rapporteerbaar wordt." },
        { "q": "Capacitieve sensor: basisrelatie en manieren om C te beïnvloeden.", "a": "C = ε₀·ε_r·A/d. Verander A, d of ε_r (medium). Meestal meet je kleine ΔC door mechanische verplaatsing of diëlektrische variatie." },
        { "q": "Voordelen van capacitieve sensoren t.o.v. inductieve?", "a": "Eenvoudige mechanica, hoge gevoeligheid, elektrische velden zijn goed te schermen/manipuleren → hoge nauwkeurigheid mogelijk." },
        { "q": "Noem drie interfacing-methoden voor capacitieve sensoren.", "a": "1) Brugschakeling (differentiële ΔC-detectie). 2) Transimpedantie (I–V converter). 3) Oscillator/time-based (f- of t-variatie met C). Eventueel C in feedback bij inverse-relaties voor lineariteit." },
        { "q": "Inductieve/Hall-sensor: kernprincipe en uitdrukking voor Hall-spanning.", "a": "Ladingen ondervinden Lorentzkracht q·v·B en bouwen een E-veld op tot evenwicht (qvB = qE). Hall-spanning: V_H = k·I·B; polariteit hangt af van teken ladingsdragers. k is veel groter in halfgeleiders dan in metalen." },
        { "q": "Variabele reluctantiesensor: leg magnetisch circuit en inductantie uit.", "a": "Reluctantie ℜ = l/(μ₀·μ_r·A). Magnetomotorische kracht ℱ = n·I. Flux Φ = ℱ/ℜ. Inductantie L = n²/ℜ → L neemt af bij grotere luchtspleet (grotere ℜ). Seriereluctanties sommeren zoals weerstanden." },
        { "q": "Hoe lineariseren/temperatuurcompenseren bij variabele reluctantiesensoren?", "a": "Differentieel opstellen (twee paden) en referentie-/compensatiespoel gebruiken; linearisatie rond werkpunt; temperatuurcompensatie via tweede inductor." },
        { "q": "Eddy-current verplaatsingssensor: gedrag bij geleiders vs. ferro-materialen.", "a": "Geleidend doel → Foucaultstromen dissiperen energie, effectieve L daalt bij naderen. Ferromagnetisch doel → μ_r stijgt, ℜ daalt, L stijgt. Vaak tweede spoel voor temperatuurcompensatie." },
        { "q": "LVDT: werkingsprincipe en waarom AC-excitatie nodig is.", "a": "Bewegende kern koppelt primaire naar twee secundaire spoelen; differentiële spanning ~ positie. AC nodig voor inductieve koppeling en om fase/informatie te demoduleren naar DC." },
        { "q": "LVDT: typische eigenschappen (lineariteit, gevoeligheid, frequentie).", "a": "Niet-lineariteit typisch ±0,5% (tot ±0,1% haalbaar). Gevoeligheid vaak als mVout per 0,001\" per Vin (frequentie vermelden!). Excitatie-frequentie ≈ 10× hoogste inputfrequentie." },
        { "q": "Wat is een RVDT en hoe verschilt het van LVDT?", "a": "Rotational Variable Differential Transformer: zelfde principe maar voor hoekmeting (typisch tot ~180°). Lage wrijving, geen borstels, hoge resolutie." },
        { "q": "Resolver/synchro: principe en typische parameters.", "a": "Koppeling ~ cosinus/sinus van hoek tussen rotor en stator; gemoduleerde uitgangen die na demodulatie hoeken geven. Typische f: 50–400–1000 Hz, resolutie 5–10 boogminuten, restspanning 20–50 mV, faselead rotor t.o.v. stator (tot ~15°)." },
        { "q": "Wat is een Inductosyn?", "a": "Planar (lineaire/roterende) variant van resolver met zeer hoge nauwkeurigheid (bv. 1 µm over 250 mm; hoekresolutie tot fracties boogseconde). Werkt met hoge frequenties (orde kHz)." },
        { "q": "Elektromagnetische tachometer: basisrelatie en waarom frequentie vaak betrouwbaarder is.", "a": "Geïnduceerde spanning U ∝ ω; het puls-/signaalfrequentie is proportioneel aan hoeksnelheid en robuuster tegen amplitudeverstoringen dan de absolute spanning." },
        { "q": "Voordelen van opto-elektronische sensoren t.o.v. elektromagnetische.", "a": "Geen ESD/EM-coupling, geen ground loops, veilige scheiding (bron/detector op veilige plek), compatibel met glasvezels/optische communicatie, geen crosstalk tussen vezels (dicht bij elkaar). Nadeel: gevoelig voor omgevingslicht, stof." },
        { "q": "Noem gangbare optische bronnen en detectoren.", "a": "Bronnen: lamp/halogeen (breed spectrum), LED (smaller, makkelijk te moduleren), laser (smal, coherente bundel). Detectoren: fotoresistor (traag), fotodiode (snel), fototransistor (minder snel dan diode), PSD, CCD/CMOS arrays." },
        { "q": "Waarom is bandgap van halfgeleider relevant voor fotodetectoren?", "a": "Fotondetectie vereist h·ν ≥ E_g; spectrale respons is beperkt tot golflengtes met voldoende fotonenergie om elektronen naar de geleidingsband te liften." },
        { "q": "Optische vezels: totaalreflectie en nut voor meetsystemen.", "a": "Totaalreflectie door brekingsindexprofiel (stap/gradueel). Leidt licht over afstanden met lage verliezen, elektrisch gescheiden en immuun voor EM-storing; nuttig voor sensoren/encoders." },
        { "q": "Optische encoders: basis en resolutieverhoging.", "a": "Schijf/lineaire schaal met raster; twee kwadratuur-signalen (90° uit fase) leveren richting. Door juiste signaalcombinatie en interpolatie kun je 2× of 4× resolutie behalen; soms analoge interpolatie of Moiré-effect." },
        { "q": "Wat doet een PSD (Position Sensitive Diode)?", "a": "Deelt fotostroom afhankelijk van lichtpositie; hoge lineariteit, nauwkeurigheid tot ~1/10000, ook 2D-varianten beschikbaar." },
        { "q": "Michelson-interferometer: waarom extreem nauwkeurig maar duur?", "a": "Gebaseerd op faseverschil/optische padlengte met lasercoherentie; sub-golflengte-resolutie over lange baselines → hoge nauwkeurigheid, maar complex/duur in praktijk." },
        { "q": "Laserafstandssensor: waarom differentiëren van het signaal nuttig?", "a": "Differentie uitgangen accentueren flankovergangen en reduceren traag veranderende drifts/stoorlicht, waardoor detectie betrouwbaarder is." },
        { "q": "Piëzo-elektrische sensor: direct/invers effect en dynamiek.", "a": "Direct: kracht → spanning op kristalvlak. Invers: spanning → mechanische verplaatsing (actuatie). Mechanisch hoge eigenfrequentie (ω₀ ~ 5e4–5e5 rad/s), demping ζ ≈ 0,01; gebruik onder resonantiefrequentie." },
        { "q": "Piëzo-sensor elektrisch model en invloed kabelcapaciteit.", "a": "Modelleer als ladingsbron + capacitieve bron (C_kristal ∥ C_kabel). Grotere C_kabel verlaagt gevoeligheid bij spanningsmeting; daarom dubbele afscherming/actieve probes en transimpedantie-meting toepassen." },
        { "q": "Waarom dubbele afscherming bij piëzo-metingen?", "a": "Om parasitaire capaciteiten van lange kabels te minimaliseren en stoorsignalen te onderdrukken; anders beïnvloedt C_kabel de outputspanning sterk." },
        { "q": "Ultrasone sensoren: twee meetmethoden en principes.", "a": "1) Discontinu (puls-echo): Time-of-Flight (TOF) van reflectie → afstand; reflectie bij impedantiesprongen. 2) Continu (gechirpte/FMCW): fase-/frequentieverschuiving → afstand en hogere nauwkeurigheid/dynamisch bereik." },
        { "q": "Wat is de reflectiecoëfficiënt bij ultrasoon en waarom relevant?", "a": "Afhankelijk van akoestische impedantieverschillen (analogie met transmissielijnen). Groter verschil → sterkere reflectie → betere detectie van grensvlakken." },
        { "q": "Waarom worden piëzo-elementen op resonantie gebruikt in ultrasone transducers?", "a": "Op resonantie is de mechanische/akoestische koppelingsfactor maximaal → hogere efficiëntie en gevoeligheid voor zenden/ontvangen." },
        { "q": "Noem drie strategieën tegen ruis/storing in meetketens.", "a": "1) Afscherming/bedrading: twisted pair, Faraday cage, kort houden van lussen. 2) Differentieel meten (CMRR verhogen), gebalanceerde lijnen, optische koppeling. 3) Filtering/modulatie/averaging afhankelijk van spectrum en signaal." },
        { "q": "Wat is CMRR en typische orde van grootte?", "a": "Common-Mode Rejection Ratio: onderdrukking van gelijkmatige storingen op beide ingangen van een differentiële versterker. Typisch ~100 dB (10⁵)." },
        { "q": "Morrison’s Rule (1977): hoe sluit je afscherming correct aan?", "a": "Verbind de afscherming met de signaalreferentie (neutral/ground) van het systeem op het referentie-aardpunt om ongewenste terugkoppelingen te vermijden; let op met lange lijnen en ground loops." },
        { "q": "Wat zijn ground loops en hoe vermijd je ze bij lange lijnen?", "a": "Stroomvloeiing via meerdere aardpunten → spanningsverschillen/ruis. Oplossing: gebalanceerde (differentiële) signaaloverdracht, afscherming correct geaard, eventueel slechts aan één zijde verbinden of optische isolatie gebruiken." },
        { "q": "Serie- vs. common-mode ruis: effect op spannings- en stroombelaste metingen?", "a": "Series-ruis staat in serie met de bron en beïnvloedt vooral spanningsmetingen met hoge impedantie. Common-mode ruis staat t.o.v. aarde; differentiële meting onderdrukt die (CMRR); belasting/weerstandswaarden beïnvloeden de mate van onderdrukking." },
        { "q": "Welke digitale nabewerking helpt de SNR te verhogen bij repetitieve signalen?", "a": "Averaging (gemiddelde over N samples verhoogt SNR met √N), en digitale filtering (bandpass/lowpass) indien ruisspectrum buiten de signaalband ligt." },
        { "q": "Binaire sensoren: kernkenmerken en aandachtspunten.", "a": "1-bit informatie (aan/uit). Simpel/goedkoop, gebruikt voor detectie/tellen. Aandacht voor drempel, gevoeligheid, hysterese (Schmitt-trigger) en debounce; triggerenergie beïnvloedt het gemeten systeem." },
        { "q": "Voorbeeld: nabijheidssensoren en hun principes.", "a": "Mechanisch (schakelaar), optisch (reflectie/laser), inductief (eddy/hall), hall-element (B-veld), ultrasoon (reflectie). Vaak analoge sensor + comparator → binair signaal; keuze hangt af van omgeving/toepassing." },
        { "q": "Waarom is ‘burst’/‘burst + average’ uitlezing nuttig bij trage/ruizige sensoren?", "a": "Meervoudige snelle metingen binnen korte tijd beperken langzame drift en verbeteren SNR via gemiddelde, zonder traag systeemgedrag." },
        { "q": "Wat is het voordeel van modulatie bij optische/inductieve sensoren?", "a": "Shift het sensorsignaal naar een hogere, ruisarmere band; na synchrone demodulatie filter je omgevingslicht/50 Hz en lagefrequente drift weg." },
        { "q": "Waarom moeten LVDT/Resolver-signalen gedemoduleerd worden?", "a": "Omdat de uitgang gemoduleerd (AC) is; demodulatie (synchroon) levert een DC-waarde die proportioneel is met positie/hoek inclusief polariteit (fase-informatie)." },
        { "q": "Waarom kruist een LVDT-uitgang niet exact door 0 V op ‘nulpositie’?", "a": "Kleine asymmetrieën, offset/restspanning en externe invloeden (belasting/fase) veroorzaken een offset; kalibratie en fasegevoelige detectie minimaliseren dit." },
        { "q": "Hoe kies je de excitatie-frequentie voor LVDT/resolver-systemen?", "a": "Kies de draaggolf ≥ ~10× de hoogste frequentiecomponent in de gemeten mechanische beweging om amplitude-/fasevervorming te beperken." },
        { "q": "Waarom is frequentiemeting vaak robuuster dan spanningsmeting (tachometer/encoder)?", "a": "Frequentie is minder gevoelig voor amplitudevariaties (ruis, veroudering, temperatuursdrift) en levert daarmee stabielere snelheidsinformaties." },
        { "q": "Welke rol speelt impedantieaanpassing in meetsystemen?", "a": "Zorgt dat de bron weinig belast wordt en maximale signaaltransfer plaatsvindt; voorkomt meetfouten door spanningsdelers en frequentie-afhankelijk gedrag." },
        { "q": "Wat is het nut van differentiële opstellingen (brug/dual-coil) bij verplaatsingssensoren?", "a": "Verhoogt gevoeligheid (tegenover common-mode variaties), lineair rond het werkpunt, en compenseert temperatuur en voedingsvariaties." },
        { "q": "Noem een praktische reden om een transimpedantieversterker te gebruiken.", "a": "Voor sensoren die primair een stroom leveren (fotodiode, ΔC-naar-I), is TIA ideaal: zet stroom direct om naar spanning met instelbare gevoeligheid via R_f." },
        { "q": "Waarom is afscherming bij capacitieve sensoren eenvoudiger dan bij inductieve?", "a": "Elektrische velden kunnen effectief met metalen schermen (Faraday) worden afgeschermd, terwijl magnetische velden (lage frequenties) moeilijker te blokkeren zijn." },
        { "q": "Welke fenomenen beperken de nauwkeurigheid van eddy-current sensoren?", "a": "Materiaalresistiviteit/temperatuursafhankelijkheid, oppervlakteruwheid, geometrie, en afstandslinearisatie; compensatiespoel en kalibratie verminderen fouten." },
        { "q": "Wanneer kies je een Hall-sensor i.p.v. een variabele-reluctantie-sensor?", "a": "Bij lage snelheden/zwakke B-velden of wanneer DC-veldmeting nodig is (VR-sensor geeft spanning ~ dΦ/dt → minder geschikt voor quasi-DC)." },
        { "q": "Waarom is het handig om capacitieve sensoren in oscillator/time-domein te lezen?", "a": "ΔC geeft direct Δf of Δt, wat nauwkeurig en ruisarm meetbaar is met digitale tellers; lineair gedrag over kleine intervallen en eenvoudige digitalisatie." },
        { "q": "Welke keuze helpt lijnkoppeling/EMI te beperken bij lange kabels?", "a": "Gebalanceerde (differentieel) transmissie, twisted pair, beperkte lusoppervlakken, correcte afscherming en eventueel aarde aan één zijde verbinden." },
        { "q": "Geef een voorbeeld van calibratieprocedure voor een LVDT.", "a": "Meet uitgangsspanning bij meerdere bekende posities rond nul → lineaire fit (gain/offset) en fasekalibratie; verifieer lineariteit/gevoeligheid bij nominale belasting en frequentie." },
        { "q": "Wat is triggerenergie bij binaire sensoren en waarom relevant?", "a": "Minimale energieverandering om de drempel te overschrijden; te hoge triggerenergie verstoort het systeem (back-action), te laag verhoogt valse triggers." },
        { "q": "Welke twee fouten introduceert een belastingsweerstand bij potmeteruitlezing?", "a": "1) Schaalfout (gain-verandering). 2) Niet-lineariteit (α-afhankelijk); beide worden erger bij lagere RL ten opzichte van R." }
      ]
    },
      {
      "id": "image-sensors-2",
      "name": "Global Shutter Pixels & 3D Imaging",
      "items": [
        { "q": "What is the main problem of rolling shutter readout?", "a": "Rolling shutter exposes rows sequentially, leading to motion artifacts such as skew, wobble, or partial exposure when objects move quickly or illumination is pulsed." },
        { "q": "How does a global shutter solve the rolling shutter problem?", "a": "Global shutter exposes all pixels simultaneously and stores charge before readout, eliminating motion-induced distortions and enabling flash synchronization." },
        { "q": "Why not simply increase the readout speed in rolling shutter to solve distortion?", "a": "Higher readout speed reduces distortion but decreases exposure time, lowering SNR. It also does not allow synchronized flash exposure since rows are still staggered." },
        { "q": "What is the difference between triggered and pipelined global shutter operation?", "a": "Triggered GS: all pixels expose at the same time, then read out later. Pipelined GS: exposure of one frame overlaps with readout of the previous frame, improving throughput but requiring in-pixel storage." },
        { "q": "Why is global shutter important for active NIR illumination systems like 3D cameras?", "a": "It allows precise synchronization of short light pulses with exposure, rejecting background light and improving depth accuracy." },
        { "q": "Define shutter efficiency and parasitic light sensitivity (PLS).", "a": "Shutter efficiency = 1 − PLS. PLS is the sensitivity of the memory node relative to the photodiode. Low PLS (e.g., −80 dB) means high shutter efficiency, crucial in bright or fast scenes." },
        { "q": "What is the principle of a 5T global shutter pixel and its limitation?", "a": "A 5T pixel uses one storage node per pixel for global shuttering. Limitation: poor shutter efficiency, reset noise, and leakage, making it unsuitable for high-performance imaging." },
        { "q": "What improvements are offered by 6T and 7T GS pixels?", "a": "They add extra transistors for correlated double sampling (CDS), improving noise and shutter efficiency. Drawback: larger area and higher fixed pattern noise from transistor mismatches." },
        { "q": "What is a charge-domain global shutter pixel?", "a": "It stores charge (not voltage) in dedicated storage nodes before readout, enabling true correlated double sampling, lower noise, and better area efficiency than voltage-domain GS pixels." },
        { "q": "What are the drawbacks of charge-domain GS pixels?", "a": "Reduced full-well capacity (storage split between nodes), potential smear from incomplete transfer, and integration challenges in back-side illuminated (BSI) sensors." },
        { "q": "What is the function of deep trench isolation (DTI) in GS pixels?", "a": "DTI isolates pixels to reduce optical/electrical crosstalk, lowers dark current, prevents blooming, and improves shutter efficiency in GS designs." },
        { "q": "Explain the principle of direct Time-of-Flight (dTOF) imaging.", "a": "A short laser pulse is sent out and photon arrival times are measured with SPADs. Distance is calculated from time delay. Requires histogramming electronics and TDCs." },
        { "q": "What is pile-up distortion in dTOF?", "a": "At high photon flux, only the first photon is detected while later photons are ignored, biasing distance measurements towards shorter values." },
        { "q": "Explain the principle of indirect TOF (iTOF).", "a": "The sensor uses modulated light and correlates incoming signals with reference modulation by gating charges into bins. Depth is extracted from phase shift or charge ratios." },
        { "q": "Give the distance formulas used in iTOF.", "a": "For pulsed iTOF: d = c·t·(Q2/(Q1+Q2))/2. For continuous wave (CW) iTOF: d = (c·t/(2π))·arctan((Q3−Q4)/(Q1−Q2))." },
        { "q": "What special pixel feature enables iTOF operation?", "a": "Dual storage bins with very fast gates (tens of MHz) that direct charge depending on the modulation phase. Gates are designed to be unidirectional to prevent charge leakage." },
        { "q": "How does stereovision calculate depth?", "a": "It uses two cameras with a fixed baseline. The disparity between the two projected points on the image plane is inversely proportional to depth." },
        { "q": "What are the main challenges in stereovision?", "a": "Finding correct matches between left and right images, handling textureless surfaces, limited depth resolution for distant objects, and correcting lens distortions." },
        { "q": "Explain the principle of structured light 3D imaging.", "a": "A projector casts a known coded pattern on the scene. A camera records the deformed pattern. By triangulation with known baseline, the depth map is reconstructed." },
        { "q": "What encoding methods are used for structured light?", "a": "Spatial coding (unique dot or stripe patterns), temporal coding (binary or Gray code sequences), and hybrid methods used in systems like Kinect or Artec scanners." },
        { "q": "Compare stereovision, structured light, and TOF approaches.", "a": "Stereovision: passive, lower hardware cost but complex matching. Structured light: active, better correspondence but sensitive to ambient light. TOF: direct depth, robust in low texture but sensitive to multipath and requires high-speed electronics." },
        { "q": "Why is shutter efficiency especially important in 3D imaging systems?", "a": "Because short NIR light bursts must be captured precisely; if parasitic light leaks into storage nodes, depth measurements degrade due to background contamination." },
        { "q": "What is the trade-off between pixel size and 3D resolution in TOF systems?", "a": "Larger pixels allow more light collection and better SNR but limit spatial resolution. Smaller pixels give higher resolution but lower sensitivity and require stronger illumination." }
      ]
  },
      {
      "id": "actuatoren",
      "name": "Actuatoren",
      "items": [
        { "q": "Wat is een actuator en hoe verschilt het van een sensor?", "a": "Een actuator zet elektrische energie om in een fysieke grootheid (meestal mechanische beweging of kracht). Een sensor doet het omgekeerde: die zet een fysieke grootheid om in een elektrisch signaal. Samen vormen ze de basis van een regelsysteem." },

        { "q": "Wat zijn de belangrijkste types actuatoren besproken in de cursus?", "a": "DC motoren (met borstels), borstelloze DC motoren (BLDC), stappenmotoren. Daarnaast worden voedingen en signaalconversiesystemen (ADC/DAC) behandeld als noodzakelijke componenten voor actuatoren." },

        { "q": "Hoe werkt een geborstelde DC motor technisch gezien?", "a": "De rotor bevat spoelen die bekrachtigd worden. Door Lorentzkracht ontstaat een koppel dat de rotor laat draaien. De collector en borstels zorgen voor commutatie: het wisselen van stroomrichting zodat de motor blijft draaien. Het toerental is ruwweg evenredig met de spanning, het koppel met de stroom." },
        { "q": "Wat zijn typische voor- en nadelen van geborstelde DC motoren?", "a": "Voordelen: eenvoudig aan te sturen (enkel spanning/stroom regelen), goedkoop, robuust. Nadelen: slijtage van borstels, vonkvorming, beperkte levensduur en efficiëntie." },
        { "q": "Hoe regel je de snelheid van een DC motor?", "a": "Door de aangelegde spanning te variëren. Voor koppelregeling wordt de stroom geregeld. PWM (pulse width modulation) is een veelgebruikte techniek." },
        { "q": "Wat gebeurt er met de tegen-EMK in een DC motor?", "a": "Tijdens rotatie induceert de rotor een tegen-EMK (back EMF) die evenredig is met de snelheid. Dit beperkt de stroom bij hoge snelheid en maakt snelheidsregeling mogelijk." },

        { "q": "Wat is een borstelloze DC motor (BLDC) en hoe werkt deze?", "a": "Bij een BLDC motor zit de spoel in de stator en de magneet in de rotor. Commutatie gebeurt elektronisch door middel van Hall-sensoren of sensorless technieken. Dit vermijdt borstels en zorgt voor hogere efficiëntie en levensduur." },
        { "q": "Wat zijn de voordelen en nadelen van BLDC motoren?", "a": "Voordelen: hoge efficiëntie, geen slijtage van borstels, geschikt voor hoge snelheden, betrouwbaar. Nadelen: complexere aansturing, duurdere elektronica nodig." },
        { "q": "Waarom worden BLDC motoren veel gebruikt in drones en elektrische voertuigen?", "a": "Ze hebben een hoge koppel/gewichtsverhouding, zijn efficiënt, betrouwbaar en onderhoudsvrij. Dit maakt ze ideaal voor toepassingen waar gewicht en autonomie cruciaal zijn." },

        { "q": "Wat is een stappenmotor en hoe werkt hij?", "a": "Een stappenmotor draait in discrete stappen. Elke puls op de spoelen verschuift de rotor met een vaste hoek. Hierdoor kan men exacte positiecontrole bekomen zonder feedbacksensor." },
        { "q": "Welke soorten stappenmotoren bestaan er?", "a": "Permanent magneet (PM), variabele reluctantie (VR), en hybride (combinatie van beide, meest gebruikt door hoge resolutie en koppel)." },
        { "q": "Wat zijn voordelen en nadelen van stappenmotoren?", "a": "Voordelen: precieze positiecontrole, eenvoudig aan te sturen, relatief goedkoop. Nadelen: resonanties, beperkt koppel bij hoge snelheid, stappenverlies mogelijk zonder feedback." },
        { "q": "Wat is microstepping en waarom wordt het toegepast?", "a": "Microstepping stuurt de spoelen aan met sinusvormige stromen waardoor de rotor tussenstappen kan innemen. Dit verhoogt resolutie en vermindert trillingen/resonanties." },
        { "q": "In welke toepassingen zijn stappenmotoren ideaal en waarom?", "a": "3D-printers, CNC-machines, scanners – overal waar precieze positionering belangrijk is en absolute snelheid minder belangrijk is." },

        { "q": "Wat zijn belastingskarakteristieken en welke 3 types zijn belangrijk voor motoren?", "a": "Constante koppelbelasting (bv. transportband), kwadratisch koppelbelasting (bv. ventilatoren/pompen, koppel ~ snelheid²), constant vermogen belasting (bv. werktuigmachines). De motorselectie moet passen bij het type belasting." },

        { "q": "Wat is het doel van spanningsregulatoren bij actuatoren?", "a": "Zorgen voor een stabiele spanning voor motoren en elektronica. Zonder dit zouden motorsnelheid en gedrag onvoorspelbaar zijn bij spanningsschommelingen." },
        { "q": "Hoe werkt een lineaire spanningsregelaar en wat zijn de voor- en nadelen?", "a": "Vergelijkt uitgangsspanning met een referentie en stuurt een transistor aan. Voordelen: eenvoudig, weinig ruis. Nadelen: lage efficiëntie, warmteverlies." },
        { "q": "Hoe werkt een schakelende (switching) spanningsregelaar en wat zijn de voor- en nadelen?", "a": "Schakelt snel tussen aan/uit en gebruikt spoelen en condensatoren om de spanning te filteren. Voordelen: hoge efficiëntie (80–95%). Nadelen: complexer, meer ruis." },

        { "q": "Wat is een ADC en waarom is het belangrijk in motorregeling?", "a": "Een Analoog-naar-Digitaal Converter zet sensorsignalen (stroom, positie, snelheid) om naar digitale waarden voor de controller. Nodig voor feedbackregeling (closed loop)." },
        { "q": "Wat is een DAC en waarom belangrijk voor actuatoren?", "a": "Een Digitaal-naar-Analoog Converter zet een digitaal stuursignaal om in een analoge spanning of stroom die motorsturing kan aandrijven." },
        { "q": "Welke soorten ADC's bestaan er en in welke situaties worden ze gebruikt?", "a": "Successieve approximatie (meest gebruikt, snel en nauwkeurig), flash (zeer snel, duur), dual ramp (nauwkeurig, traag), delta-sigma (zeer nauwkeurig, voor lage frequenties)." },
        { "q": "Wat is quantisatiefout bij ADC’s?", "a": "Omdat een continue ingang wordt afgerond naar discrete stappen, ontstaat er een maximale fout van ±0,5 LSB (least significant bit)." },

        { "q": "Vergelijk DC motor, BLDC motor en stappenmotor in termen van aansturing en toepassingen.", "a": "DC: eenvoudig, geschikt voor variabele snelheid, maar slijtage. BLDC: complexer, geschikt voor hoge prestaties en duurzaamheid. Stappenmotor: precieze positiecontrole zonder feedback, maar beperkt vermogen/snelheid." },
        { "q": "Welke actuator kies je voor een CNC-machine en waarom?", "a": "Een stappenmotor (of servo) omdat je nauwkeurige en reproduceerbare positionering nodig hebt." },
        { "q": "Welke actuator kies je voor een drone en waarom?", "a": "Een BLDC motor: hoog vermogen/gewicht, hoge efficiëntie, betrouwbare werking bij hoge snelheden." },
        { "q": "Waarom is een DC motor geschikt voor speelgoedtoepassingen?", "a": "Eenvoudig en goedkoop aan te sturen, robuust, en lage eisen aan levensduur of efficiëntie." }
      ]
    },
    {
      "id": "examen-vragen",
      "name": "Examen Vragen",
      "items": [
        { "q": "Metingen worden beïnvloed door statische effecten en statistische effecten (ruis). Wat is het verschil en geef van elk een voorbeeld.", "a": "Statisch = systematisch, reproduceerbaar (middelen ≠ 0): offset, gainfout, niet-lineariteit, hysterese; vb. voltmeter met vaste +20 mV offset. Statistisch = willekeurig (middelen → 0): thermische/shotruis; vb. uitlezing die ±1 mV fluctueert." },
        { "q": "De tekening toont een meetsysteem. Kies een grootheid en beschrijf de functie (en het principe) van elk blok.", "a": "Voorbeeld temperatuur: (1) Sensor (RTD/thermistor) → elektrisch. (2) Conditionering (brug, buffer/opamp, filtering, S/H). (3) ADC (digitaliseert, resolutie/kwantisatie). (4) Digitale verwerking (linearisatie, calibratie, filtering). (5) Weergave/actuator (display/regellus)." },
        { "q": "Wat betekenen ‘resolutie’ en ‘meetnauwkeurigheid’? Wat is het verschil en impact op een potentiometer?", "a": "Resolutie = kleinste stap (bv. 1 LSB of mechanische stap). Nauwkeurigheid = nabijheid tot de ware waarde (incl. offset/gain/linearity). Potentiometer: beperkte resolutie → ‘trapjes’; bron-/belastingsweerstanden veroorzaken schaalfout en niet-lineariteit." },
        { "q": "Wat is hysteresis? Kan je dit schetsen?", "a": "Hysteresis: uitgang hangt af van richting van verandering. Bij oplopen/aflopen verschillende drempels → dode band. Schets: twee S-curves met gescheiden inschakel- en uitschakelniveaus." },
        { "q": "Bereken de invloed van ladingseffecten (sample-and-hold) in een bron Rs die een ingangscapaciteit Cin laadt gedurende Ts.", "a": "Vhold = Vin·(1 − e^{−Ts/(Rs·Cin)}). Fout ΔV ≈ Vin·e^{−Ts/(Rs·Cin)}. Verminder met lagere Rs, kleinere Cin, langere Ts of bufferversterker (volger)." },
        { "q": "Bespreek de impact van bron- en belastingsweerstand in een potentiometerschema. Geef Vout als functie van α.", "a": "Ideaal: Vout = α·Vs. Met bron Rs en belasting RL: Vout = Vs · ((α·Rp ∥ RL) / (Rs + (α·Rp ∥ RL) + (1−α)·Rp)). Dit geeft α-afhankelijke niet-lineariteit en schaalfout (kleine RL verergert)." },
        { "q": "Onbekend schema: hoe bepaal je functie en werking systematisch?", "a": "1) Identificeer bron/sensor. 2) Zoek impedantieaanpassing/brug. 3) Herken conditionering (versterker, filter, gelijkrichting). 4) Isolatie/beveiliging. 5) Conversie (ADC/DAC, S/H). 6) Uitgang/regellus. Koppel blokken aan doel: linearisatie, ruisonderdrukking, domeinconversie." },
        { "q": "Hoe werkt een rekstrookje (strain gauge)?", "a": "Weerstand van meander verandert met rek ε: ΔR/R = GF·ε. In Wheatstonebrug wordt kleine ΔR naar spanning omgezet; dummy-gauges compenseren temperatuur." },
        { "q": "Wat is de rekfactor (gauge factor) en hoe optimaliseer je die?", "a": "GF = (ΔR/R)/ε; komt uit geometrie en piezoresistief effect. Optimalisatie: materiaalkeuze (hogere piezoresistiviteit), volle brug, goede mechanische koppeling, temperatuurcompensatie." },
        { "q": "Conceptuele capacitieve accelerometer: leid ΔC(a) af.", "a": "Massa-veer vormt condensator. Verplaatsing x = a/ω0² (ω0² = k/m). C = εA/(d−x) ⇒ voor kleine x: ΔC ≈ (εA/d²)·x = (εA/d²)·(a/ω0²). Differentiële opstelling verdubbelt gevoeligheid en onderdrukt common-mode." },
        { "q": "Noem vier methodes om een capacitieve sensor uit te lezen.", "a": "(1) Brugmeting (AC). (2) Transimpedantie (I→V). (3) Oscillator/frequentiemeting (f ∝ 1/C). (4) Tijd-/ladingsmeting (RC-laadtijd, Q-transfer)." },
        { "q": "Hoe werkt een Hall-element?", "a": "Geleider met stroom I in B-veld → Lorentzkracht duwt ladingsdragers zijwaarts → Hall-spanning VH ∝ I·B/(q·n·t). Output evenredig met B; vaak met conditionering en hysterese." },
        { "q": "Wat is reluctantie en hoe maak je er een sensor mee? Voorbeeld.", "a": "Reluctantie ℜ = l/(μA). Verplaatsingen die luchtspleet wijzigen veranderen ℜ, dus flux/inductie. Toepassing: inductieve naderingsschakelaar, LVDT/resolver, Inductosyn." },
        { "q": "Voordelen van LASER t.o.v. LED?", "a": "Laser: smal spectrum, coherentie, collimatie, hoge irradiantie → lange afstand, kleine spot, interferometrie/structured light. LED: goedkoper/robuust maar minder gericht." },
        { "q": "Hoe werkt een optische encoder? Types, limiterende factor, verbeteringen.", "a": "Lichtbron + raster + detector. Types: incrementeel (A/B, Z) en absoluut (Gray). Resolutie beperkt door lijnafstand/optiek/ruis; verbeter via quadratuur×4, analoge sin/cos-interpolatie, grotere diameter/fijner raster." },
        { "q": "Nadelen van CCD t.o.v. CMOS beeldsensoren?", "a": "Hoger verbruik, lagere integratie (ADC/logic off-chip), smear/need shutter, trager systeemintegration. CMOS: 4T/PPD, on-chip ADC/logic, lagere power → dominantie in consumentenmarkt." },
        { "q": "Wat betekent het Fermi-niveau Ef?", "a": "Chemisch potentiaal van elektronen; energie met 50% bezettingskans. In intrinsiek Si ~ midden bandkloof; doping verschuift Ef en beïnvloedt depletie en sensorparameters." },
        { "q": "Leg het foto-elektrisch effect uit.", "a": "Fotonen met energie hν ≥ Eg genereren e–h-paren; in fotodiode verzamelt intern veld ladingsdragers → fotostroom/meetbaar signaal. QE bepaalt efficiëntie." },
        { "q": "Verschil tussen ‘gewone’ diode en fotodiode?", "a": "Gewone diode geoptimaliseerd voor geleiding/rectificatie. Fotodiode (omgekeerd gepolariseerd) heeft grotere depletielaag, lage donkerstroom en optische respons → stroom/spanningsverandering bij licht." },
        { "q": "Wat is de ‘grote truc’ van de pinned photodiode (PPD) en het voordeel?", "a": "Begraven opslag met volledig gedepleteerd startpunt; volledige ladingstransfer naar sense node en CDS → lage kTC-ruis en lage dark current." },
        { "q": "Rolling vs global shutter: probleem en twee oplossingen.", "a": "Rolling leest rij-per-rij → skew/vervorming. Oplossingen: (1) Voltage-domein GS (5T/6T/8T) met in-pixel opslag; (2) Charge-domein GS met mini-CCD/BSI/DTI. Beide maken simultane belichting mogelijk." },
        { "q": "Wat is ‘shutter efficiency’ en hoe verbeter je die?", "a": "Shutter efficiency = 1 − PLS (parasitic light sensitivity). Verbeter via lichtschild over opslagnode, DTI, BSI-optimalisaties, golfgeleiders en charge-domein GS." },
        { "q": "Welke aanpak verwijdert kTC-ruis effectief in pixels?", "a": "Volledige ladingstransfer van PPD naar sense node + correlated double sampling (CDS)." },
        { "q": "Waarom SPAD-arrays bij direct ToF 3D-camera’s? Wat is een SPAD?", "a": "dToF vereist enkel-foton gevoeligheid en ns/ps-timing. SPAD = single-photon avalanche diode in Geiger-modus; met TDC/histogramming meet je aankomsttijd → afstand." },
        { "q": "Welke methodes zijn er voor 3D-opname via stereo?", "a": "(1) Passieve stereovisie, (2) Gestructureerd licht (actief), (3) iToF (fase/correlatie), (4) dToF (puls/arrivaltime)." },
        { "q": "Welke fouten komen in DAC/ADC voor?", "a": "Offset, gain, INL, DNL (→ missing codes, niet-monotonie), ruis/kwantisatie, jitter, referentiefouten." },
        { "q": "Wat is een inherent monotone DAC? Voor- en nadelen.", "a": "Thermometer-codering of gesegmenteerd ontwerp garandeert monotoniciteit (geen code-terugval). Voordelen: robuust. Nadelen: meer area/complexiteit dan puur R-2R." },
        { "q": "Hoe werkt een SAR-ADC?", "a": "Binaire zoekactie: interne DAC zet hypothese, comparator beslist, SAR-register update. Na N stappen N-bit resultaat; snel en energiezuinig." },
        { "q": "Single-ramp vs dual-ramp ADC: werking en welk probleem lost dual-ramp op?", "a": "Single-ramp vergelijkt Vin met lineaire ramp → gevoelig voor ruis/tijdreferentie. Dual-ramp integreert eerst Vin dan −Vref; tijdverhouding ∝ Vin en onderdrukt storingen/ref-ruis." },
        { "q": "Hoe werkt een delta-sigma (ΔΣ) ADC?", "a": "Oversampling + noise shaping met (bijv.) 1-bit quantizer; digitaal filter/decimatie levert hoge resolutie met eenvoudige analoge blokken." },
        { "q": "Waarom zorgt de tegen-EMK van een DC-motor voor zelf-regeling?", "a": "Eb = k_e·ω. Bij belasting daalt ω → Eb daalt → Ia = (V − Eb)/Ra stijgt → koppel T = k_t·Ia stijgt en compenseert de belasting." },
        { "q": "Voorwaarde voor maximaal vermogen van een DC-motor?", "a": "P = T·ω maximaal rond halve onbelast-snelheid: T ≈ ½·Tstall en ω ≈ ½·ω0 (benadering)." },
        { "q": "Hoe verhoudt koppel van een DC-motor zich tot ankerstroom? Geldt dit altijd?", "a": "T ≈ k_t·Ia (lineair) voor DC en per-fase voor BLDC. Stappenmotoren leveren koppel in discrete stappen; hun koppel daalt sterk met snelheid (pull-in/out)." },
        { "q": "Welke verliezen treden op in een DC-motor?", "a": "Koper I²R, ijzer (hysterese/wervelstromen), wrijving (lagers/borstels), ventilatie en commutatieverliezen." },
        { "q": "Vergelijk T–I–ω-curves voor DC, BLDC en stappenmotor en bespreek verschillen.", "a": "DC: T–I lineair; T–ω aflopend; max P rond ½ω0. BLDC: vergelijkbaar maar met elektronische commutatie en brede vlakke T-zone. Stepper: hoog stilstandskoppel, sterk koppelverlies op snelheid (pull-in/pull-out)." },
        { "q": "Leg de werking van een BLDC uit.", "a": "Statorwikkelingen + rotorpermanenten; elektronische commutatie creëert roterend veld dat rotor volgt (positie via Hall of sensorless)." },
        { "q": "Hoe wordt een BLDC gevoed/aangestuurd?", "a": "Driefase-inverter (6 MOSFET’s), commutatiesequentie op basis van rotorpositie, PWM voor koppel/snelheid, stroombegrenzing en dead-timebeheer." },
        { "q": "Hoe werkt positieregeling van een BLDC?", "a": "Positie via Hall/observer; snelheidslus (PI) en eventueel positieslus. FOC (field-oriented control) met sinusstromen reduceert koppelrimpel en verbetert dynamiek." },
        { "q": "Basisprincipe van een stappenmotor.", "a": "Discrete stappen per puls; positie = som van stappen. Microstepping gebruikt sinusvormige fase-stromen voor tussenposities en minder resonantie." },
        { "q": "Hoe werkt een hybride stappenmotor en welke voor-/nadelen neemt hij over?", "a": "Combineert permanente magneet en variabele reluctantie: fijne staphoek, hoog koppel/volume. Nadelen: resonanties, koppelval op snelheid (open-loop)." },
        { "q": "Vergelijk unipolaire met bipolaire aansturing van een stappenmotor.", "a": "Unipolair: eenvoudiger, lagere effectieve koperbenutting/ koppel. Bipolair: H-bruggen, volle wikkeling actief → meer koppel/efficiëntie maar complexer." },
        { "q": "Hoe beïnvloed je het inschakelgedrag van een stappenmotor via het circuit?", "a": "Stroomchopping/current-mode drivers, microstepping, juiste acceleratieprofielen, voldoende busspanning en ‘decay’-instellingen voor snelle stroomopbouw/afbouw." },
        { "q": "Impact van inertie op koppel (grafisch, pull-in/out).", "a": "Hoge inertie verschuift pull-in curve naar lagere snelheden; voor dezelfde stapfrequentie is meer koppel nodig om te versnellen → risico op stapverlies zonder ramp-up." },
        { "q": "Teken/bespreek een voeding die een DC-spanning zonder spikes levert.", "a": "Netfilter (L–C), gelijkrichting (brug), bufferelco met bleeder, snubbers/TVS, decoupling dicht bij last, daarna lineaire of schakelende regelaar met juiste layout/EMI-beheer." },
        { "q": "Wat is een bleederweerstand?", "a": "Hoge weerstand parallel over buffercondensator om veilig te ontladen en minimale belasting te geven (stabiliteit). Nadeel: continu klein vermogensverlies P = V²/R." }
      ]
    }



  ]
},
{
  "id": "sensors-actuators",
  "name": "Sensoren & Actuatoren",
  "chapters": [
      {
        "id": "introduction",
        "name": "Introduction",
        "items": [
          { "q": "Wat is het verschil tussen een communicatie netwerk en een computer netwerk?", "a": "Communicatienetwerk: structuur van entiteiten (mensen, machines) waarin informatie kan stromen op basis van afspraken (protocollen). Computernetwerk: structuur van apparaten (end systems) waarin data kan stromen; dit is een specifiek type communicatienetwerk." },
          { "q": "Noem drie voordelen van computernetwerken.", "a": "Eenvoudige informatie-uitwisseling tussen eindapparaten; delen van middelen zoals printers; efficiënt gebruik van het communicatiekanaal; flexibel en configureerbaar; minder bekabeling; robuuster en fouttoleranter." },
          { "q": "Wat is het verschil tussen simplex, half-duplex en full-duplex datatransmissie?", "a": "Simplex: data kan maar in één richting; Half-duplex: data in beide richtingen maar niet tegelijk; Full-duplex: data kan gelijktijdig in beide richtingen." },
          { "q": "Geef twee voorbeelden van verbindingsvormen en hun toepassing.", "a": "Point-to-point: directe verbinding tussen twee hosts (bv. professor–student gesprek). Multipoint: meerdere apparaten delen één link (bv. professor die les geeft aan een klas)." },
          { "q": "Wat is het verschil tussen een LAN en een WAN?", "a": "LAN (Local Area Network): klein, bv. binnen een kantoor of gebouw, verbonden via switch. WAN (Wide Area Network): verbindt LANs over grote afstand, bv. via routers en backbone infrastructuur." },
          { "q": "Beschrijf kort de mesh, star en bus topologie.", "a": "Mesh: elk apparaat verbonden met elk ander, zeer robuust maar veel bekabeling. Star: alle apparaten verbonden via een centrale switch, eenvoudig uit te breiden. Bus: één gedeelde kabel waarop alle apparaten 'tappen', eenvoudig maar kwetsbaar voor fouten." },
          { "q": "Wat is het verschil tussen een bericht (message) en een pakket (packet)?", "a": "Message: geheel van controle- of gebruikersdata dat verzonden wordt. Voor verzending wordt het opgedeeld in kleinere stukjes met header, dit zijn de packets. Packets worden apart over het netwerk gestuurd en bij de bestemming weer samengevoegd." },
          { "q": "Wat is packet switching en wat zijn mogelijke defecten onderweg?", "a": "Packet switching: elk bericht wordt opgesplitst in pakketten die elk een eigen pad kunnen nemen via switches en routers. Onderweg kunnen vertragingen, verlies, duplicatie of corruptie optreden door drukke routers, slechte links of configuratiefouten." },
          { "q": "Leg het store-and-forward principe uit en één nadeel ervan.", "a": "Een switch/router ontvangt eerst een volledig pakket, inspecteert het, en stuurt het daarna door naar de juiste link. Nadeel: extra vertraging door bufferen en wachtrijen." },
          { "q": "Som de vier soorten packet delays op en leg kort uit.", "a": "Processing delay: tijd om header te inspecteren en op fouten te checken. Queuing delay: wachttijd in de buffer. Transmission delay: tijd om alle bits het medium op te zetten (L/R). Propagation delay: tijd voor een bit om fysiek van zender naar ontvanger te reizen." },
          { "q": "Bereken de transmissiedelay voor een pakket van 1.500 bytes over een link van 10 Mbps.", "a": "L = 1500 × 8 = 12000 bits. R = 10 Mbps = 10×10^6 bps. ttrans = L/R = 12000 / 10e6 = 0.0012 s = 1.2 ms." },
          { "q": "Welke tools kunnen gebruikt worden om de route en vertraging van pakketten te meten? Leg uit.", "a": "Traceroute (Linux), tracert (Windows) en mtr (Linux). Ze sturen probe packets met oplopende TTL’s en meten welke routers onderweg antwoorden met ICMP time exceeded. Zo zie je elke hop en de round-trip tijd." }
        ]
      },
      {
      "id": "layered-model",
      "name": "Layered Model",
      "items": [
        { "q": "Waarom gebruiken we een gelaagd communicatiemodel?", "a": "Omdat complexe communicatie tussen apparaten kan opgesplitst worden in eenvoudige taken. Elke laag voert een specifiek deel van de communicatie uit en biedt een gestandaardiseerde interface naar de lagen erboven en eronder." },
        { "q": "Wat is het verschil tussen het OSI model en het TCP/IP model?", "a": "OSI: theoretisch referentiemodel met 7 lagen, gepubliceerd in 1984 door ISO. TCP/IP: praktisch protocolstack, ouder en dominant in gebruik, meestal beschreven met 4 of 5 lagen (Application, Transport, Internet, Network Access/Link)." },
        { "q": "Geef voor elke OSI-laag een belangrijke functie.", "a": "1 Physical: bits als signalen verzenden. 2 Data-Link: frames, fysieke adressering (MAC), foutdetectie. 3 Network: routing, logische adressering (IP). 4 Transport: end-to-end, segmenten, betrouwbaarheid (TCP/UDP). 5 Session: sessiebeheer. 6 Presentation: vertaling, compressie, encryptie. 7 Application: interface naar gebruiker (HTTP, SMTP, DNS)." },
        { "q": "Geef voor elke OSI-laag een voorbeeld van een protocol.", "a": "Physical: Ethernet (1000BASE-T), WiFi (802.11). Data-Link: PPP, Ethernet II. Network: IPv4, IPv6, ICMP. Transport: TCP, UDP, SCTP. Session: sockets, NetBIOS. Presentation: JPEG, TLS, ASCII/EBCDIC. Application: HTTP(S), DNS, SMTP, FTP, DHCP." },
        { "q": "Wat is encapsulatie in netwerken?", "a": "Het proces waarbij elke laag eigen headers (en soms trailers) toevoegt aan de data van de bovenliggende laag. Zo wordt een bericht → segment → datagram → frame → bits." },
        { "q": "Wat is de volgorde van protocol data units (PDU’s) per OSI-laag?", "a": "Physical: bits, Data-Link: frames, Network: packets/datagrams, Transport: segments, Session: SPDU, Presentation: PPDU, Application: APDU." },
        { "q": "Wat is de rol van standaardisatieorganisaties zoals IEEE en IETF?", "a": "IEEE: standaarden voor fysieke en linklagen (Ethernet, WiFi). IETF: Internetprotocollen zoals TCP/IP en RFC’s. ISO: OSI-model en algemene standaarden. W3C: webstandaarden zoals HTML, HTTP." },
        { "q": "Wat is het verschil tussen de functie van een switch, router en firewall in termen van lagen?", "a": "Switch: werkt op de Data-Link laag (MAC-adressen). Router: werkt op de Netwerklaag (IP-adressen). Firewall/NAT-router: werkt op Transport + hogere lagen (ports, sockets, filtering)." },
        { "q": "Hoe verloopt de de-encapsulatie van een datapakket?", "a": "Bij de ontvanger wordt stap voor stap de header/trailer van elke laag verwijderd en de data naar de bovenliggende laag doorgestuurd, tot de applicatie de originele boodschap ontvangt." },
        { "q": "Wat is het verschil tussen fysieke en logische adressering?", "a": "Fysiek: MAC-adressen op de Data-Link laag, uniek per netwerkkaart. Logisch: IP-adressen op de Netwerklaag, hiërarchisch en nodig voor routing tussen netwerken." },
        { "q": "Waarom zeggen we dat TCP/IP een protocolsuite is en niet enkel TCP en IP?", "a": "Omdat het veel meer protocollen bevat op verschillende lagen: applicatieprotocollen (HTTP, SMTP, DNS), transportprotocollen (TCP, UDP, SCTP), netwerkprotocollen (IPv4, IPv6, ICMP) en linkprotocollen (Ethernet, WiFi, PPP)." },
        { "q": "Geef een concreet voorbeeld van encapsulatie met HTTP.", "a": "HTTP bericht → TCP segment met poortnummers → IP datagram met bron- en doeladres → Ethernet frame met bron- en doel-MAC → bits op fysieke laag." }
      ]
    },
    {
      "id": "link-layer",
      "name": "Link Layer",
      "items": [
        { "q": "Wat is de hoofdtaak van de Link Layer?", "a": "Het versturen van frames tussen knooppunten (1 hop), inclusief framing, mediumtoegang, foutdetectie/correctie en soms betrouwbare overdracht." },
        { "q": "Welke foutdetectiemethoden bestaan er in de Link Layer?", "a": "Parity check (1-bit fout detectie), Checksum (ones’ complement optelling, volgorde-onafhankelijk), en Cyclic Redundancy Check (CRC, detecteert meerdere fouten via generatorpolynoom)." },
        { "q": "Wat is het verschil tussen TDM, FDM en CDMA?", "a": "TDM verdeelt de tijd in slots per gebruiker; FDM verdeelt het frequentiespectrum; CDMA gebruikt unieke codes zodat meerdere gebruikers tegelijk dezelfde frequentieband kunnen gebruiken." },
        { "q": "Wat is CSMA en wat is het verschil met ALOHA?", "a": "CSMA (Carrier Sense Multiple Access) luistert eerst of het kanaal vrij is, ALOHA zendt gewoon en wacht op een ACK. CSMA kan ook collision detectie/avoidance toepassen (CSMA/CD, CSMA/CA)." },
        { "q": "Geef een voorbeeld van een 'Taking turns'-protocol.", "a": "Polling (centrale master vraagt elke node om te zenden, bv. Bluetooth) of Token Passing (token-ring, FDDI)." },
        { "q": "Wat is een MAC-adres en welke soorten communicatie ondersteunt Ethernet?", "a": "Een 48-bit hardware-adres, wereldwijd uniek. Ondersteunt unicast (1:1), broadcast (1:all, FF-FF-FF-FF-FF-FF) en multicast (1:n)." },
        { "q": "Beschrijf kort de Ethernet frame structuur.", "a": "Preamble (8 bytes sync), bron/dest. MAC (6 bytes elk), Type (protocol, bv. IPv4 = 0x0800), Payload (46–1500 bytes), en CRC (4 bytes)." },
        { "q": "Wat doet een switch op de link layer?", "a": "Verbindt Ethernet-segmenten transparant, houdt een MAC-tabel bij om te filteren/forwarden, en leert zelf welke MAC-adressen op welke poort zitten." },
        { "q": "Wat is ARP en waarvoor wordt het gebruikt?", "a": "Address Resolution Protocol vertaalt IP-adressen naar MAC-adressen binnen een LAN, door middel van broadcast requests en unicast replies." },
        { "q": "Wat is een VLAN en waarom wordt het gebruikt?", "a": "Virtual LAN’s segmenteren een netwerk logisch in meerdere broadcast-domeinen voor betere controle, beveiliging en minder broadcastverkeer." },
        { "q": "Wat is trunking en hoe wordt dit geïmplementeerd?", "a": "Trunking verbindt meerdere VLAN’s over switches. Hiervoor wordt IEEE 802.1Q tagging gebruikt (4-byte extra header met VLAN-ID tot 4096 VLANs)." },
        { "q": "Wat is DOCSIS en hoe werkt upstream/downstream verkeer?", "a": "Data-Over-Cable Service Interface Specification: kabelmodem standaard. Downstream = één naar veel (FDM), Upstream = veel naar één (CSMA/CD requests en taking-turns voor data)." }
      ]
    },
    {
      "id": "network-layer",
      "name": "Network Layer",
      "items": [
        { "q": "Wat zijn de belangrijkste taken van de Network Layer?", "a": "Het transporteren van datagrammen tussen hosts via meerdere netwerken. Taken: logisch adresseren (IP), routering (padkeuze), forwarding, fragmentatie, en gebruik van protocollen zoals ICMP." },
        { "q": "Wat is het verschil tussen direct en indirect routing?", "a": "Direct routing: bron en bestemming in hetzelfde subnet, ARP vertaalt IP naar MAC. Indirect routing: bron en bestemming in verschillende subnetten, pakket gaat via router(s) met behulp van forwarding tables." },
        { "q": "Wat is het verschil tussen forwarding en routing?", "a": "Forwarding: doorsturen van pakketten volgens de lokale tabel (per hop). Routing: bepalen van de end-to-end route via routing-algoritmes (OSPF, BGP)." },
        { "q": "Beschrijf kort het IPv4 headerformaat.", "a": "20 bytes standaard header met velden zoals versie, headerlengte, type of service, lengte, identificatie/flags/offset (fragmentatie), TTL, protocol (TCP/UDP), header checksum, bron- en bestemmingsadres, en optioneel extra velden." },
        { "q": "Wat is fragmentatie in IPv4 en hoe werkt het?", "a": "Wanneer een IP-datagram groter is dan de MTU, splitst de router het op in fragmenten met eigen header. De offset geeft positie aan (in blokken van 8 bytes). Alleen de eindhost voegt de fragmenten weer samen." },
        { "q": "Wat is CIDR en hoe wordt het genoteerd?", "a": "Classless Inter-Domain Routing vervangt classful indeling. Notatie: IP/prefix (bijv. 192.168.1.0/24). Het aantal 1-bits in de mask geeft het netwerkdeel aan, rest = hosts." },
        { "q": "Hoeveel bruikbare hosts zijn er in een /24 subnet?", "a": "2^(32-24) = 2^8 = 256 adressen. Min 2 (netwerkadres + broadcast) = 254 bruikbare hostadressen." },
        { "q": "Noem drie gereserveerde IPv4 adressen en hun betekenis.", "a": "0.0.0.0 (dit host), 127.0.0.1 (loopback), 255.255.255.255 (broadcast). Ook netwerkadres (bijv. 192.168.1.0) en subnet-broadcast (bijv. 192.168.1.255)." },
        { "q": "Wat is het verschil tussen Link State en Distance Vector routing?", "a": "Link State (OSPF): elke node kent volledige netwerkmap en berekent kortste pad. Distance Vector (BGP): nodes wisselen info uit met buren, kennen enkel beste volgende hop." },
        { "q": "Wat is ICMP en waarvoor wordt het gebruikt?", "a": "Internet Control Message Protocol meldt fouten en statusinformatie, bv. destination unreachable, time exceeded. Wordt gebruikt door tools zoals ping en traceroute." },
        { "q": "Hoe werkt IPv4 multicast direct routing?", "a": "Multicast IP-adres (224.0.0.0/4) wordt direct vertaald naar een multicast MAC-adres (01-00-5E-xx-xx-xx). Link layer accepteert meerdere MAC-adressen per interface." },
        { "q": "Hoe werkt IPv4 multicast indirect routing?", "a": "Hosts schrijven zich in via IGMP. Routers bouwen een multicast distributieboom en verspreiden pakketten alleen naar netwerken met geïnteresseerde hosts. Scope wordt beperkt door TTL." },
        { "q": "Noem drie verbeteringen van IPv6 t.o.v. IPv4.", "a": "128-bit adresruimte (onuitputtelijk), eenvoudiger header (40 bytes, geen checksum), geen ARP maar Neighbor Discovery (ICMPv6), geen broadcast (multicast in plaats daarvan)." },
        { "q": "Geef drie voorbeelden van IPv6 speciale adressen.", "a": "::1 (loopback), fe80::/10 (link-local), fc00::/7 (unique local), ff00::/8 (multicast), 2000::/3 (global unicast)." },
        { "q": "Wat is een link-local IPv6 adres en waarvoor wordt het gebruikt?", "a": "Automatisch toegekend adres in fe80::/10. Nodig voor communicatie binnen hetzelfde link-segment en voor Neighbor Discovery." },
        { "q": "Wat is het doel van Neighbor Discovery Protocol (NDP) in IPv6?", "a": "Vervangt ARP, gebruikt ICMPv6 om IP-adressen naar MAC-adressen te mappen, router discovery, duplicate address detection, en multicast group management." }
      ]
    },
        {
      "id": "transport-layer",
      "name": "Transport Layer",
      "items": [
        { "q": "Wat zijn de belangrijkste taken van de Transport Layer?", "a": "End-to-end communicatie, encapsulatie van applicatiedata, multiplexing/demultiplexing met poorten, betrouwbare dataoverdracht, en congestiecontrole." },
        { "q": "Wat is het verschil tussen TCP en UDP?", "a": "TCP is connection-oriented, betrouwbaar, biedt volgorde en flow/congestiecontrole. UDP is connectionless, snel, weinig overhead, maar geen betrouwbaarheid of volgorde." },
        { "q": "Wat is een socket en hoe wordt het geïdentificeerd?", "a": "Een socket is de binding van een transportprotocol met een poort. Bij TCP/UDP wordt een verbinding geïdentificeerd door een 4-tuple: [bron-IP, bronpoort, doel-IP, doelpoort]." },
        { "q": "Noem enkele toepassingen die typisch UDP gebruiken.", "a": "DNS, VoIP, video/audio streaming, online gaming." },
        { "q": "Noem enkele toepassingen die typisch TCP gebruiken.", "a": "HTTP(S), FTP, SMTP, IMAP, SSH." },
        { "q": "Beschrijf kort de TCP-header velden.", "a": "Bevat bron- en doelpoort, sequentienummer, acknowledgmentnummer, headerlengte, flags (SYN, ACK, FIN), window size, checksum, urgent pointer en optioneel opties (MSS)." },
        { "q": "Wat is het doel van sequentienummers en acknowledgements in TCP?", "a": "Sequentienummers nummeren bytes zodat de ontvanger volgorde kan herstellen. Acknowledgements bevestigen ontvangst en geven het volgende verwachte byte aan." },
        { "q": "Wat is het verschil tussen stop-and-wait en sliding window?", "a": "Stop-and-wait: zender wacht op ACK na elk pakket, inefficiënt. Sliding window: meerdere pakketten mogen in-flight zijn voordat ACK’s terugkomen, veel efficiënter." },
        { "q": "Hoe schat TCP de timeout voor hertransmissies in?", "a": "TCP meet Round-Trip Time (RTT), berekent een gewogen gemiddelde (EstimatedRTT), en zet de timeout op EstimatedRTT + 4 × standaarddeviatie." },
        { "q": "Wat is de 3-way handshake en waarvoor dient het?", "a": "Setup-proces voor een TCP-verbinding: 1) SYN van client, 2) SYN-ACK van server, 3) ACK van client. Zorgt voor synchronisatie van sequentienummers en bevestiging dat beide kanten klaar zijn." },
        { "q": "Wat is de 4-way handshake in TCP?", "a": "Het afsluiten van een TCP-verbinding: elke kant stuurt een FIN en ontvangt een ACK, in totaal 4 berichten." },
        { "q": "Wat is flow control in TCP en hoe werkt het?", "a": "Mechanisme waarbij de ontvanger via het window size veld aangeeft hoeveel buffer er nog vrij is. Zender stuurt nooit meer data dan de ontvanger kan bufferen." },
        { "q": "Wat is congestiecontrole en hoe detecteert TCP congestie?", "a": "Zender verlaagt snelheid bij congestie. Congestie wordt gedetecteerd via langere RTT’s, timeouts of duplicate ACK’s. ECN kan netwerk-assist geven." },
        { "q": "Wat is 'slow start' in TCP?", "a": "Congestiecontrole-algoritme waarbij de congestion window exponentieel groeit vanaf 1 segment totdat congestie optreedt. Daarna schakelt TCP over naar lineaire groei (congestion avoidance)." },
        { "q": "Hoe combineert TCP flow control en congestiecontrole?", "a": "Het effectieve verzendvenster = min(flow control window, congestion window)." },
        { "q": "Wat is NAT en waarom wordt het gebruikt?", "a": "Network Address Translation vertaalt private IP-adressen naar een publiek adres, zodat meerdere hosts 1 publiek IPv4-adres kunnen delen. Opgelost tekort aan IPv4-adressen." },
        { "q": "Wat is het verschil tussen NAT en PAT?", "a": "NAT vertaalt interne adressen naar externe adressen. PAT (Port Address Translation) vertaalt meerdere interne adressen naar 1 publiek IP met verschillende poortnummers." },
        { "q": "Noem drie private IPv4-adresbereiken.", "a": "10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16." }
      ]
    },
    {
      "id": "wireless-networks",
      "name": "Wireless Networks",
      "items": [
        { "q": "Wat is het verschil tussen een ad-hoc netwerk en een infrastructuur netwerk?", "a": "Ad-hoc: geen basisstation, directe communicatie tussen hosts (bv. Bluetooth, Wi-Fi Direct). Infrastructuur: communicatie via basisstation of AP, ondersteunt handoff (bv. Wi-Fi, GSM, 4G, 5G)." },
        { "q": "Noem drie problemen die typisch zijn voor draadloze transmissie.", "a": "Afname van signaalsterkte met afstand, interferentie van andere bronnen (ruis, verborgen terminal), en multipath-propagatie." },
        { "q": "Wat is de relatie tussen SNR, bit rate en bit error rate (BER)?", "a": "Hogere SNR → lagere BER. Bij eenzelfde SNR leidt een hogere bit rate tot hogere BER. Rate adaptation past modulatie aan de kanaalkwaliteit aan." },
        { "q": "Wat is CSMA/CA en in welk protocol wordt het gebruikt?", "a": "Carrier Sense Multiple Access with Collision Avoidance. Gebruikt in Wi-Fi (802.11) om botsingen te vermijden door eerst kanaal te checken en RTS/CTS/ACK mechanismen te gebruiken." },
        { "q": "Wat is een SSID en hoe associeert een client zich met een AP?", "a": "SSID = Service Set Identifier. Een AP adverteert via beacon frames, een client kan probe requests versturen en daarna associëren via authentication en association frames." },
        { "q": "Beschrijf kort het 802.11 MAC frame.", "a": "Bevat Frame control, Duration (kanaalreservatie), 4x MAC-adressen, Sequence control, Payload (meestal IP-datagram), en CRC." },
        { "q": "Wat is het doel van RTS/CTS/ACK in Wi-Fi?", "a": "RTS/CTS voorkomt botsingen door kanaalreservering en informeert verborgen stations. ACK bevestigt correcte ontvangst van het frame." },
        { "q": "Hoe werkt handover tussen access points in Wi-Fi?", "a": "Client detecteert beter signaal, stuurt re-association request naar nieuwe AP. MAC-tabel wordt geüpdatet via IAPP. Sleutels kunnen via 802.11r/RADIUS uitgewisseld worden." },
        { "q": "Hoe werkt power management in Wi-Fi?", "a": "Client kan slapen tussen beacon frames, AP buffert data en vermeldt dit in beacon. Client wordt kort wakker om data op te halen." },
        { "q": "Wat zijn de frequentiebanden en kanalen voor Wi-Fi?", "a": "2.4 GHz band (13 kanalen in EU), 5 GHz band (~27 kanalen in EU). Beide backward compatible en MIMO mogelijk." },
        { "q": "Welke frequentiebanden gebruikt 4G LTE en 5G?", "a": "4G: 800 MHz, 1.7 GHz, 2.6 GHz. 5G: 0.45–6 GHz en 25–52 GHz." },
        { "q": "Wat is de rol van MME en HSS in 4G LTE?", "a": "MME: authenticatie, tunneling en mobiliteitsbeheer. HSS: database met IMSI en sleutels voor authenticatie." },
        { "q": "Wat is de rol van de S-GW en P-GW in 4G LTE?", "a": "S-GW: eerste hop, tunnelt verkeer naar provider netwerk. P-GW: kent IP-adressen toe (NAT), fungeert als edge-router naar het internet." },
        { "q": "Beschrijf kort het handover-proces in 4G LTE.", "a": "Bron-basisstation kiest target, reserveert resources, informeert mobiel toestel, forward tijdelijk verkeer. Daarna update MME en S-GW de tunnel, en verkeer gaat via nieuwe basisstation." }
      ]
    }
    
    ]
}

  ]
}




